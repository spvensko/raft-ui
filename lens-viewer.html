<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LENS Viewer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>
  <script src="https://unpkg.com/lucide@0.263.0/dist/umd/lucide.min.js"></script>
  <style>
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    .icon { display: inline-flex; align-items: center; justify-content: center; }
    .icon-spin { animation: spin 1s linear infinite; }
  </style>
</head>
<body class="bg-gray-50 min-h-screen">
  <div id="root">
    <div class="p-8 font-sans">
      <p>Loading LENS Viewer...</p>
      <p class="text-gray-500 text-sm">If this message persists, check your browser console for errors.</p>
    </div>
  </div>
  <script type="text/babel" data-presets="react">
    const { useState, useMemo, useEffect, useRef } = React;

    // Icon component using Lucide
    const Icon = ({ name, size = 24, color = 'currentColor', className = '' }) => {
      const ref = useRef(null);
      useEffect(() => {
        if (ref.current && lucide.icons[name]) {
          ref.current.innerHTML = '';
          const svg = lucide.createElement(lucide.icons[name]);
          svg.setAttribute('width', size);
          svg.setAttribute('height', size);
          svg.setAttribute('stroke', color);
          if (className) svg.setAttribute('class', className);
          ref.current.appendChild(svg);
        }
      }, [name, size, color, className]);
      return <span ref={ref} className="icon" style={{ width: size, height: size }} />;
    };

    // API base for preloading
    const API_BASE = window.location.origin;
    const getUrlParams = () => {
      const params = new URLSearchParams(window.location.search);
      return {
        preload: params.get('preload') || '',
        preloadQc: params.get('preload_qc') || '',
        projectId: params.get('project_id') || ''
      };
    };

    // Priority metrics
    const priorityMetrics = [
      { value: 'priority_score_maximum', label: 'Maximum Priority Score' },
      { value: 'priority_score_mhcflurry', label: 'MHCFlurry Priority Score' },
      { value: 'priority_score_mhcflurry_no_ccf', label: 'MHCFlurry Priority Score (No CCF)' },
      { value: 'mhcflurry_2.1.1.aff', label: 'MHCFlurry Binding Affinity' },
      { value: 'mhcflurry_2.1.1.pres_score', label: 'MHCFlurry Presentation Score' },
      { value: 'ccf', label: 'Cancer Cell Fraction' },
      { value: 'vaf', label: 'Variant Allele Frequency' },
    ];

    const visMetrics = ['priority_score_maximum', 'priority_score_mhcflurry', 'mhcflurry_2.1.1.aff', 'ccf', 'vaf', 'tpm'];

    // Main Component
    const LENSViewer = () => {
      const [patients, setPatients] = useState({});
      const [selectedPatient, setSelectedPatient] = useState(null);
      const [topN, setTopN] = useState(25);
      const [sortMetric, setSortMetric] = useState('priority_score_maximum');
      const [selectedAlleles, setSelectedAlleles] = useState(new Set());
      const [selectedAntigenSources, setSelectedAntigenSources] = useState(new Set());
      const [comments, setComments] = useState({});
      const [showDataTable, setShowDataTable] = useState(false);
      const [selectedRow, setSelectedRow] = useState(null);
      const [showAlleleTable, setShowAlleleTable] = useState(true);
      const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
      const [viewMode, setViewMode] = useState('patient');
      const [globalFormula, setGlobalFormula] = useState('');
      const [patientFormulas, setPatientFormulas] = useState({});
      const [patientTopN, setPatientTopN] = useState({});
      const [patientSortMetrics, setPatientSortMetrics] = useState({});
      const [isPreloading, setIsPreloading] = useState(false);
      const [preloadError, setPreloadError] = useState('');
      const [showPasteModal, setShowPasteModal] = useState(false);
      const [pasteData, setPasteData] = useState('');
      const [pasteError, setPasteError] = useState('');
      const [mobileView, setMobileView] = useState('visualizations'); // 'visualizations' or 'pmhcs'
      const [patientTab, setPatientTab] = useState('pmhc'); // 'pmhc' or 'qc'
      const [qcData, setQcData] = useState({}); // QC data organized by patient/sample
      const [cohortQcData, setCohortQcData] = useState(null); // Cohort-level QC summary
      const [manifestData, setManifestData] = useState(null); // Manifest group data
      const [selectedGroup, setSelectedGroup] = useState(null); // Current group for multi-group patients

      // CRC32 implementation for checksum verification
      const crc32 = (str) => {
        const table = (() => {
          const t = [];
          for (let i = 0; i < 256; i++) {
            let c = i;
            for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
            t[i] = c;
          }
          return t;
        })();
        let crc = 0xFFFFFFFF;
        for (let i = 0; i < str.length; i++) crc = table[(crc ^ str.charCodeAt(i)) & 0xFF] ^ (crc >>> 8);
        return (crc ^ 0xFFFFFFFF) >>> 0;
      };

      // Decode RAFT-encoded data from CLI
      const decodeRaftData = (encoded) => {
        const MAGIC = 'RAFT1:';
        if (!encoded.startsWith(MAGIC)) {
          throw new Error('Invalid format. Expected RAFT-encoded string starting with RAFT1:');
        }

        // Extract and verify checksum (last 8 hex chars after final colon)
        const lastColonIdx = encoded.lastIndexOf(':');
        const checksumHex = encoded.slice(lastColonIdx + 1);
        if (!/^[0-9a-f]{8}$/i.test(checksumHex)) {
          throw new Error('Invalid or missing checksum. Make sure you copied the entire string.');
        }
        const dataWithoutChecksum = encoded.slice(0, lastColonIdx);
        const expectedChecksum = parseInt(checksumHex, 16);
        const actualChecksum = crc32(dataWithoutChecksum);
        if (actualChecksum !== expectedChecksum) {
          throw new Error(`Checksum mismatch! The string may be incomplete or corrupted.\nExpected: ${checksumHex}, Got: ${actualChecksum.toString(16).padStart(8, '0')}\nMake sure you copied the entire string including the checksum at the end.`);
        }

        const remainder = dataWithoutChecksum.slice(MAGIC.length);
        const colonIdx = remainder.indexOf(':');
        if (colonIdx === -1) throw new Error('Invalid format. Missing data type.');
        const dataType = remainder.slice(0, colonIdx);
        const base64Data = remainder.slice(colonIdx + 1);
        if (dataType !== 'lens-data') {
          throw new Error(`Unexpected data type: ${dataType}. Expected lens-data.`);
        }
        // Decode base64 and decompress
        const binaryStr = atob(base64Data);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) bytes[i] = binaryStr.charCodeAt(i);
        // Use DecompressionStream for gzip decompression
        return new Promise((resolve, reject) => {
          const ds = new DecompressionStream('gzip');
          const writer = ds.writable.getWriter();
          writer.write(bytes);
          writer.close();
          new Response(ds.readable).text().then(resolve).catch(reject);
        });
      };

      // Handle paste from CLI
      const handlePasteSubmit = async () => {
        setPasteError('');
        try {
          const cleanData = pasteData.trim();
          if (!cleanData) {
            setPasteError('Please paste the code from the CLI.');
            return;
          }
          const jsonStr = await decodeRaftData(cleanData);
          const files = JSON.parse(jsonStr);
          let parsed = {};
          for (const [filename, content] of Object.entries(files)) {
            parsed = parseFileContent(filename, content, parsed, manifestData);
          }
          setPatients({...parsed});
          const firstId = Object.keys(parsed).sort()[0];
          if (firstId) {
            setSelectedPatient(firstId);
            const patient = parsed[firstId];
            if (patient.isMultiGroup && patient.groups.length > 0) {
              setSelectedGroup(patient.groups[0]);
              const groupData = patient.groupData[patient.groups[0]];
              setSelectedAlleles(new Set(groupData.alleles));
              setSelectedAntigenSources(new Set(groupData.antigenSources));
            } else {
              setSelectedAlleles(new Set(patient.alleles));
              setSelectedAntigenSources(new Set(patient.antigenSources));
            }
          }
          setShowPasteModal(false);
          setPasteData('');
        } catch (e) {
          setPasteError(`Failed to decode: ${e.message}`);
        }
      };

      // Parse file content with group support
      const parseFileContent = (filename, content, parsedPatients, manifest = null) => {
        const lines = content.split('\n');
        if (lines.length < 2) return parsedPatients;
        const headers = lines[0].split('\t');

        // Extract patient ID from filename
        const basename = filename.split('/').pop();
        const match = basename.match(/^[^-]+-([^-]+)-/);
        const patientId = match ? match[1] : basename.split('.')[0].split('-')[0] || basename.split('_')[0];

        // Determine which groups this file belongs to
        const runNames = extractRunNamesFromFilename(filename);
        const fileGroups = determineFileGroups(runNames, manifest);

        // Parse data rows
        const data = [];
        for (let i = 1; i < lines.length; i++) {
          if (!lines[i].trim()) continue;
          const values = lines[i].split('\t');
          const row = {};
          headers.forEach((header, idx) => { row[header] = values[idx]; });
          data.push(row);
        }

        // Check if this patient has multiple groups in manifest
        const patientManifest = manifest?.patients?.[patientId];
        const isMultiGroup = patientManifest && patientManifest.groups && patientManifest.groups.length > 1;

        // Initialize patient if not exists
        if (!parsedPatients[patientId]) {
          if (isMultiGroup) {
            // Multi-group patient: hierarchical structure
            parsedPatients[patientId] = {
              id: patientId,
              isMultiGroup: true,
              groups: [...patientManifest.groups],
              groupData: {},
              // Also maintain flat data for compatibility
              files: [],
              data: [],
              alleles: new Set(),
              alleleSupport: {},
              antigenSources: new Set()
            };
            // Initialize each group
            for (const group of patientManifest.groups) {
              parsedPatients[patientId].groupData[group] = {
                files: [],
                data: [],
                alleles: new Set(),
                alleleSupport: {},
                antigenSources: new Set()
              };
            }
          } else {
            // Single-group patient: flat structure (backward compatible)
            parsedPatients[patientId] = {
              id: patientId,
              isMultiGroup: false,
              groups: fileGroups.length > 0 ? fileGroups : ['default'],
              files: [],
              data: [],
              alleles: new Set(),
              alleleSupport: {},
              antigenSources: new Set()
            };
          }
        }

        // Helper to add data to a group structure
        const addDataToGroup = (groupData) => {
          groupData.files.push(filename);
          groupData.data.push(...data);
          data.forEach(row => {
            if (row.allele) {
              groupData.alleles.add(row.allele);
              if (!groupData.alleleSupport[row.allele]) {
                groupData.alleleSupport[row.allele] = {};
              }
              if (row.hla_allele_support) {
                row.hla_allele_support.split(';').forEach(support => {
                  const [tool, sampleType] = support.split(':');
                  if (tool && sampleType) {
                    if (!groupData.alleleSupport[row.allele][tool]) {
                      groupData.alleleSupport[row.allele][tool] = new Set();
                    }
                    groupData.alleleSupport[row.allele][tool].add(sampleType);
                  }
                });
              }
            }
            if (row.antigen_source) {
              groupData.antigenSources.add(row.antigen_source);
            }
          });
        };

        // Add data to appropriate groups
        if (parsedPatients[patientId].isMultiGroup) {
          // Add to specific groups this file belongs to
          for (const group of fileGroups) {
            if (parsedPatients[patientId].groupData[group]) {
              addDataToGroup(parsedPatients[patientId].groupData[group]);
            }
          }
          // Also add to flat structure for overall views
          addDataToGroup(parsedPatients[patientId]);
        } else {
          // Single-group: just add to flat structure
          addDataToGroup(parsedPatients[patientId]);
        }

        return parsedPatients;
      };

      // Fetch manifest group data
      useEffect(() => {
        const loadManifestData = async () => {
          try {
            const resp = await fetch(`${API_BASE}/api/manifest-groups`);
            if (resp.ok) {
              const data = await resp.json();
              if (data && (data.has_multi_group || Object.keys(data.patients || {}).length > 0)) {
                setManifestData(data);
              }
            }
          } catch (e) {
            console.warn('No manifest data available:', e);
          }
        };
        loadManifestData();
      }, []);

      // Fetch QC data from backend
      useEffect(() => {
        const loadQcData = async () => {
          try {
            const resp = await fetch(`${API_BASE}/api/qc-data`);
            if (resp.ok) {
              const data = await resp.json();
              if (data && Object.keys(data.patients || {}).length > 0) {
                setQcData(data);
              }
            }
          } catch (e) {
            console.warn('No QC data available:', e);
          }
        };
        loadQcData();
      }, []);

      // Extract run names from filename (separated by '+')
      const extractRunNamesFromFilename = (filename) => {
        // Remove directory prefix if present (lens/filename.tsv -> filename.tsv)
        const basename = filename.split('/').pop();
        // Run names are separated by '+' in the filename
        // Example: PROJ-PAT001-ad-PAT001-pre+nd-PAT001-normal.lens.tsv
        const parts = basename.split('+');
        const runNames = [];
        for (const part of parts) {
          // Extract run name pattern: prefix-identifier (e.g., ad-PAT001-pre, nd-PAT001-normal)
          const match = part.match(/((?:ad|ar|nd|nr)-[^.+]+)/);
          if (match) {
            runNames.push(match[1]);
          }
        }
        return runNames;
      };

      // Determine which groups a file belongs to based on run names
      const determineFileGroups = (runNames, manifest) => {
        if (!manifest || !manifest.run_to_groups || runNames.length === 0) {
          return ['default'];
        }

        const allGroups = manifest.all_groups || ['default'];

        // A file belongs to a group if ALL its run names are members of that group
        return allGroups.filter(group =>
          runNames.every(runName => {
            const runGroups = manifest.run_to_groups[runName];
            return runGroups && runGroups.includes(group);
          })
        );
      };

      // Preload files from server
      useEffect(() => {
        const urlParams = getUrlParams();
        if (!urlParams.preload) return;

        const loadFiles = async () => {
          setIsPreloading(true);
          try {
            // First fetch manifest data if not already loaded
            let manifest = manifestData;
            if (!manifest) {
              try {
                const manifestResp = await fetch(`${API_BASE}/api/manifest-groups`);
                if (manifestResp.ok) {
                  manifest = await manifestResp.json();
                  setManifestData(manifest);
                }
              } catch (e) { /* ignore */ }
            }

            const listResp = await fetch(`${API_BASE}/api/files?dir=${encodeURIComponent(urlParams.preload)}`);
            if (!listResp.ok) throw new Error('Failed to list files');
            const { files } = await listResp.json();
            if (files.length === 0) { setPreloadError('No TSV files found.'); setIsPreloading(false); return; }

            let parsed = {};
            for (const file of files) {
              const contentResp = await fetch(`${API_BASE}/api/file-content?path=${encodeURIComponent(file.path)}`);
              if (contentResp.ok) {
                const { name, content } = await contentResp.json();
                parsed = parseFileContent(name, content, parsed, manifest);
              }
            }

            setPatients({...parsed});
            const firstId = Object.keys(parsed).sort()[0];
            if (firstId) {
              setSelectedPatient(firstId);
              const patient = parsed[firstId];
              // For multi-group patients, auto-select first group
              if (patient.isMultiGroup && patient.groups.length > 0) {
                setSelectedGroup(patient.groups[0]);
                const groupData = patient.groupData[patient.groups[0]];
                setSelectedAlleles(new Set(groupData.alleles));
                setSelectedAntigenSources(new Set(groupData.antigenSources));
              } else {
                setSelectedAlleles(new Set(patient.alleles));
                setSelectedAntigenSources(new Set(patient.antigenSources));
              }
            }
          } catch (e) { setPreloadError(`Load failed: ${e.message}`); }
          setIsPreloading(false);
        };
        loadFiles();
      }, []);

      // Responsive behavior - auto-collapse sidebar on smaller screens
      useEffect(() => {
        const handleResize = () => {
          if (window.innerWidth < 1024) {
            setSidebarCollapsed(true);
          }
        };
        handleResize(); // Check on mount
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      // Handle file upload
      const handleFileUpload = (e) => {
        const fileList = Array.from(e.target.files);
        let parsed = {};
        let processed = 0;

        fileList.forEach(file => {
          const reader = new FileReader();
          reader.onload = (ev) => {
            parsed = parseFileContent(file.name, ev.target.result, parsed, manifestData);
            processed++;
            if (processed === fileList.length) {
              setPatients({...parsed});
              const firstId = Object.keys(parsed).sort()[0];
              if (firstId) {
                setSelectedPatient(firstId);
                const patient = parsed[firstId];
                if (patient.isMultiGroup && patient.groups.length > 0) {
                  setSelectedGroup(patient.groups[0]);
                  const groupData = patient.groupData[patient.groups[0]];
                  setSelectedAlleles(new Set(groupData.alleles));
                  setSelectedAntigenSources(new Set(groupData.antigenSources));
                } else {
                  setSelectedAlleles(new Set(patient.alleles));
                  setSelectedAntigenSources(new Set(patient.antigenSources));
                }
              }
            }
          };
          reader.readAsText(file);
        });
      };

      // Formula evaluation
      const evaluateFormula = (formula, row, allRows) => {
        if (!formula || !formula.trim()) return null;
        try {
          let expression = formula.trim();

          // Handle bound1() function
          const bound1Regex = /bound1\(([^)]+)\)/g;
          expression = expression.replace(bound1Regex, (match, columnName) => {
            const col = columnName.trim();
            const values = allRows.map(r => parseFloat(r[col])).filter(v => !isNaN(v) && v > 0);
            if (values.length === 0) return '0';
            const maxValue = Math.max(...values);
            const currentValue = parseFloat(row[col]);
            if (isNaN(currentValue) || maxValue === 0) return '0';
            return ((currentValue / maxValue) * 100).toString();
          });

          // Replace column names
          const columns = Object.keys(row).sort((a, b) => b.length - a.length);
          columns.forEach(col => {
            const value = parseFloat(row[col]);
            const numValue = isNaN(value) ? 0 : value;
            const regex = new RegExp(`\\b${col.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'g');
            expression = expression.replace(regex, numValue.toString());
          });

          expression = expression.replace(/\bmin\b/g, 'Math.min').replace(/\bmax\b/g, 'Math.max');
          const result = new Function(`return ${expression}`)();
          return isNaN(result) ? null : result;
        } catch (error) { return null; }
      };

      const getActiveFormula = () => patientFormulas[selectedPatient] || globalFormula;
      const getActiveTopN = () => patientTopN[selectedPatient] !== undefined ? patientTopN[selectedPatient] : topN;
      const getActiveSortMetric = () => patientSortMetrics[selectedPatient] || sortMetric;

      // Get the data source for current patient (group-aware)
      const getPatientDataSource = () => {
        if (!selectedPatient || !patients[selectedPatient]) return [];
        const patient = patients[selectedPatient];
        // For multi-group patients, use group-specific data (unless showing joint analysis)
        if (patient.isMultiGroup && selectedGroup && selectedGroup !== 'joint' && patient.groupData[selectedGroup]) {
          return patient.groupData[selectedGroup].data;
        }
        // For single-group or joint analysis, use all data
        return patient.data;
      };

      // Current patient data (filtered and sorted)
      const currentPatientData = useMemo(() => {
        let data = getPatientDataSource();
        if (data.length === 0) return [];

        if (selectedAlleles.size > 0) {
          data = data.filter(row => selectedAlleles.has(row.allele));
        }
        if (selectedAntigenSources.size > 0) {
          data = data.filter(row => selectedAntigenSources.has(row.antigen_source));
        }

        const formula = getActiveFormula();
        if (formula && formula.trim()) {
          data = data.map(row => ({ ...row, custom_score: evaluateFormula(formula, row, data) }));
        }

        const activeSortMetric = (formula && formula.trim()) ? 'custom_score' : getActiveSortMetric();
        data = [...data].sort((a, b) => (parseFloat(b[activeSortMetric]) || 0) - (parseFloat(a[activeSortMetric]) || 0));

        return data.slice(0, getActiveTopN());
      }, [selectedPatient, patients, selectedGroup, selectedAlleles, selectedAntigenSources, sortMetric, topN, globalFormula, patientFormulas, patientTopN, patientSortMetrics]);

      // Full filtered data (for visualizations)
      const fullPatientData = useMemo(() => {
        let data = getPatientDataSource();
        if (data.length === 0) return [];
        if (selectedAlleles.size > 0) data = data.filter(row => selectedAlleles.has(row.allele));
        if (selectedAntigenSources.size > 0) data = data.filter(row => selectedAntigenSources.has(row.antigen_source));
        const activeSortMetric = getActiveSortMetric();
        return [...data].sort((a, b) => (parseFloat(b[activeSortMetric]) || 0) - (parseFloat(a[activeSortMetric]) || 0));
      }, [selectedPatient, patients, selectedGroup, selectedAlleles, selectedAntigenSources, sortMetric, patientSortMetrics]);

      // All patients data
      const allPatientsData = useMemo(() => {
        const allData = [];
        Object.values(patients).forEach(patient => {
          patient.data.forEach(row => { allData.push({ ...row, patientId: patient.id }); });
        });
        return allData;
      }, [patients]);

      const toggleAllele = (allele) => {
        const newSet = new Set(selectedAlleles);
        newSet.has(allele) ? newSet.delete(allele) : newSet.add(allele);
        setSelectedAlleles(newSet);
      };

      const toggleAntigenSource = (source) => {
        const newSet = new Set(selectedAntigenSources);
        newSet.has(source) ? newSet.delete(source) : newSet.add(source);
        setSelectedAntigenSources(newSet);
      };

      const generateReport = () => {
        const reportData = {
          patients: Object.keys(patients),
          selectedPatient,
          topN: getActiveTopN(),
          sortMetric: getActiveSortMetric(),
          comments,
          timestamp: new Date().toISOString(),
          data: currentPatientData.map(row => ({
            peptide: row.peptide, allele: row.allele,
            priority_score: row[getActiveSortMetric()],
            comment: comments[`${row.peptide}-${row.allele}`] || ''
          }))
        };
        const blob = new Blob([JSON.stringify(reportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `lens_report_${selectedPatient}_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
      };

      // Upload screen
      if (Object.keys(patients).length === 0) {
        return (
          <div className="min-h-screen bg-gray-50 p-4 md:p-6">
            <Header />
            <div className="max-w-3xl mx-auto mt-12">
              <div className="bg-white rounded-lg shadow-md p-8 text-center border-2 border-dashed border-gray-300">
                {isPreloading ? (
                  <>
                    <div className="mx-auto mb-6 w-16 h-16 flex items-center justify-center">
                      <Icon name="loader-2" size={48} color="#6b7280" className="animate-spin" />
                    </div>
                    <h2 className="text-2xl font-bold text-gray-800 mb-2">Loading LENS Reports...</h2>
                    <p className="text-gray-500">Please wait while we fetch your data.</p>
                  </>
                ) : (
                  <>
                    {preloadError && (
                      <div className="bg-red-50 border border-red-200 rounded-md p-4 mb-6 text-red-700 text-sm">
                        {preloadError}
                      </div>
                    )}
                    <div className="mx-auto mb-6 w-16 h-16 flex items-center justify-center">
                      <Icon name="upload" size={48} color="#6b7280" />
                    </div>
                    <h2 className="text-2xl font-bold text-gray-800 mb-2">Upload LENS Reports</h2>
                    <p className="text-gray-600 mb-6 leading-relaxed">
                      Select one or more TSV report files to begin analysis.<br />
                      Each file will be parsed and organized by patient identifier.
                    </p>
                    <div className="flex gap-4 justify-center flex-wrap">
                      <label className="inline-block px-6 py-3 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition cursor-pointer text-sm font-medium">
                        Choose Files
                        <input type="file" multiple accept=".tsv,.txt" onChange={handleFileUpload} className="hidden" />
                      </label>
                      <button
                        onClick={() => setShowPasteModal(true)}
                        className="px-6 py-3 bg-gray-700 text-white rounded-md hover:bg-gray-800 transition cursor-pointer text-sm font-medium flex items-center gap-2"
                      >
                        <Icon name="clipboard-paste" size={18} />
                        Paste from CLI
                      </button>
                    </div>
                    <p className="text-gray-500 text-xs mt-4">
                      Running in headless mode? Use "Paste from CLI" to load data from RAFT.
                    </p>
                  </>
                )}
              </div>
            </div>

            {/* Paste Modal */}
            {showPasteModal && (
              <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6">
                  <div className="flex justify-between items-center mb-4">
                    <h3 className="text-lg font-semibold text-gray-800">Paste Data from CLI</h3>
                    <button onClick={() => { setShowPasteModal(false); setPasteError(''); setPasteData(''); }} className="text-gray-500 hover:text-gray-700 cursor-pointer">
                      <Icon name="x" size={24} />
                    </button>
                  </div>
                  <p className="text-sm text-gray-600 mb-4">
                    Paste the encoded data string from the RAFT CLI output below.
                    The string starts with <code className="bg-gray-100 px-1 rounded">RAFT1:lens-data:</code> and ends with a checksum.
                    <br /><span className="text-gray-500">Make sure to copy the entire string including the final 8-character checksum.</span>
                  </p>
                  {pasteError && (
                    <div className="bg-red-50 border border-red-200 rounded-md p-3 mb-4 text-red-700 text-sm">
                      {pasteError}
                    </div>
                  )}
                  <textarea
                    value={pasteData}
                    onChange={(e) => setPasteData(e.target.value)}
                    placeholder="Paste RAFT1:lens-data:... here"
                    className="w-full h-40 px-3 py-2 border border-gray-300 rounded-md font-mono text-xs focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                  />
                  <div className="flex justify-end gap-3 mt-4">
                    <button
                      onClick={() => { setShowPasteModal(false); setPasteError(''); setPasteData(''); }}
                      className="px-4 py-2 text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50 transition cursor-pointer text-sm font-medium"
                    >
                      Cancel
                    </button>
                    <button
                      onClick={handlePasteSubmit}
                      className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition cursor-pointer text-sm font-medium"
                    >
                      Load Data
                    </button>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      // Main interface
      return (
        <div className="min-h-screen bg-gray-50">
          <Header />
          <div className="flex" style={{ minHeight: 'calc(100vh - 80px)' }}>
            {/* Sidebar */}
            <Sidebar
              patients={patients}
              selectedPatient={selectedPatient}
              setSelectedPatient={setSelectedPatient}
              setSelectedAlleles={setSelectedAlleles}
              setSelectedAntigenSources={setSelectedAntigenSources}
              sidebarCollapsed={sidebarCollapsed}
              setSidebarCollapsed={setSidebarCollapsed}
              viewMode={viewMode}
              setViewMode={setViewMode}
              qcData={qcData}
              selectedGroup={selectedGroup}
              setSelectedGroup={setSelectedGroup}
            />

            {/* Main Content */}
            <div className="flex-1 overflow-y-auto p-4 md:p-6 flex flex-col">
              {viewMode === 'global-settings' ? (
                <div className="overflow-y-auto flex-1">
                  <GlobalSettings
                    topN={topN} setTopN={setTopN}
                    sortMetric={sortMetric} setSortMetric={setSortMetric}
                    globalFormula={globalFormula} setGlobalFormula={setGlobalFormula}
                  />
                </div>
              ) : viewMode === 'cohort-qc' ? (
                <div className="overflow-y-auto flex-1">
                  <CohortQCView qcData={qcData} patients={patients} manifestData={manifestData} />
                </div>
              ) : (
                <div className="flex flex-col flex-1 min-h-0">
                  {/* Patient-level tabs: pMHC vs QC */}
                  <div className="flex-shrink-0 mb-4 sticky top-0 z-10 bg-gray-50 -mx-4 md:-mx-6 px-4 md:px-6 pt-1 pb-2">
                    <div className="flex border-b border-gray-200">
                      <button
                        onClick={() => setPatientTab('pmhc')}
                        className={`px-6 py-2 text-sm font-medium transition border-b-2 ${
                          patientTab === 'pmhc'
                            ? 'text-indigo-600 border-indigo-600'
                            : 'text-gray-500 border-transparent hover:text-gray-700'
                        }`}
                      >
                        pMHC Analysis
                      </button>
                      <button
                        onClick={() => setPatientTab('qc')}
                        className={`px-6 py-2 text-sm font-medium transition border-b-2 ${
                          patientTab === 'qc'
                            ? 'text-emerald-600 border-emerald-600'
                            : 'text-gray-500 border-transparent hover:text-gray-700'
                        }`}
                      >
                        Quality Control
                      </button>
                    </div>
                  </div>

                  {patientTab === 'pmhc' ? (
                  <React.Fragment>
                  {/* Group sub-tabs for multi-group patients */}
                  {patients[selectedPatient]?.isMultiGroup && (
                    <div className="flex-shrink-0 mb-3">
                      <div className="flex flex-wrap gap-1 bg-gray-100 p-1 rounded-lg">
                        {patients[selectedPatient].groups.map(group => (
                          <button
                            key={group}
                            onClick={() => {
                              setSelectedGroup(group);
                              const groupData = patients[selectedPatient].groupData[group];
                              if (groupData) {
                                setSelectedAlleles(new Set(groupData.alleles));
                                setSelectedAntigenSources(new Set(groupData.antigenSources));
                              }
                            }}
                            className={`px-3 py-1.5 text-sm font-medium rounded-md transition ${
                              selectedGroup === group
                                ? 'bg-white text-indigo-700 shadow-sm'
                                : 'text-gray-600 hover:text-gray-800'
                            }`}
                          >
                            <Icon name="folder" size={14} className="inline mr-1" />
                            {group}
                            <span className="text-xs text-gray-400 ml-1">
                              ({patients[selectedPatient].groupData[group]?.data.length || 0})
                            </span>
                          </button>
                        ))}
                        <button
                          onClick={() => {
                            setSelectedGroup('joint');
                            const patient = patients[selectedPatient];
                            setSelectedAlleles(new Set(patient.alleles));
                            setSelectedAntigenSources(new Set(patient.antigenSources));
                          }}
                          className={`px-3 py-1.5 text-sm font-medium rounded-md transition ${
                            selectedGroup === 'joint'
                              ? 'bg-white text-purple-700 shadow-sm'
                              : 'text-gray-600 hover:text-gray-800'
                          }`}
                        >
                          <Icon name="git-compare" size={14} className="inline mr-1" />
                          Joint Analysis
                        </button>
                      </div>
                    </div>
                  )}

                  {/* Joint Analysis mode within pMHC tab */}
                  {selectedGroup === 'joint' && patients[selectedPatient]?.isMultiGroup ? (
                    <div className="flex-1 overflow-y-auto">
                      <JointAnalysisPanel
                        patient={patients[selectedPatient]}
                        qcData={qcData[selectedPatient]}
                      />
                    </div>
                  ) : (
                  <React.Fragment>
                  {/* Controls */}
                  <div className="flex-shrink-0">
                    <PatientControls
                      selectedPatient={selectedPatient}
                      patients={patients}
                      topN={topN}
                      sortMetric={sortMetric}
                      patientTopN={patientTopN} setPatientTopN={setPatientTopN}
                      patientSortMetrics={patientSortMetrics} setPatientSortMetrics={setPatientSortMetrics}
                      patientFormulas={patientFormulas} setPatientFormulas={setPatientFormulas}
                      globalFormula={globalFormula}
                      selectedAntigenSources={selectedAntigenSources}
                      toggleAntigenSource={toggleAntigenSource}
                      selectedAlleles={selectedAlleles}
                      toggleAllele={toggleAllele}
                      showAlleleTable={showAlleleTable} setShowAlleleTable={setShowAlleleTable}
                      showDataTable={showDataTable} setShowDataTable={setShowDataTable}
                      generateReport={generateReport}
                      selectedGroup={selectedGroup}
                    />
                  </div>
                  {/* Split panel: Visualizations on left, pMHC cards on right */}
                  {/* On small screens: tabs to switch views. On large screens: sticky sidebar + flowing cards */}
                  <div className="flex flex-col lg:flex-row lg:items-start gap-4">
                    {/* Mobile/Tablet: View toggle tabs */}
                    <div className="lg:hidden flex border-b border-gray-200 mb-2">
                      <button
                        onClick={() => setMobileView('visualizations')}
                        className={`flex-1 py-2 text-sm font-medium transition ${mobileView === 'visualizations' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-gray-500'}`}
                      >
                        Visualizations
                      </button>
                      <button
                        onClick={() => setMobileView('pmhcs')}
                        className={`flex-1 py-2 text-sm font-medium transition ${mobileView === 'pmhcs' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-gray-500'}`}
                      >
                        Top pMHCs
                      </button>
                    </div>

                    {/* Left Panel: Visualizations (sticky on desktop) */}
                    <div className={`lg:w-1/2 ${mobileView !== 'visualizations' ? 'hidden lg:block' : ''}`}>
                      <div className="lg:sticky lg:top-[60px] lg:max-h-[calc(100vh-90px)] lg:overflow-y-auto lg:pr-2">
                        <VisualizationPanel
                          fullPatientData={fullPatientData}
                          topNData={currentPatientData}
                          allPatientsData={allPatientsData}
                          sortMetric={getActiveSortMetric()}
                          selectedRow={selectedRow}
                          setSelectedRow={setSelectedRow}
                          topN={getActiveTopN()}
                          selectedPatient={selectedPatient}
                        />
                      </div>
                    </div>

                    {/* Right Panel: Data Table + pMHC Cards */}
                    <div className={`lg:w-1/2 ${mobileView !== 'pmhcs' ? 'hidden lg:block' : ''}`}>
                      <div className="lg:pl-2">
                        {showDataTable && (
                          <DataTable
                            data={currentPatientData}
                            selectedRow={selectedRow}
                            setSelectedRow={setSelectedRow}
                            hasCustomFormula={!!(getActiveFormula() && getActiveFormula().trim())}
                          />
                        )}

                        <PMHCCards
                          data={currentPatientData}
                          sortMetric={getActiveSortMetric()}
                          comments={comments}
                          setComments={setComments}
                          selectedRow={selectedRow}
                          setSelectedRow={setSelectedRow}
                          hasCustomFormula={!!(getActiveFormula() && getActiveFormula().trim())}
                        />
                      </div>
                    </div>
                  </div>
                  </React.Fragment>
                  )}
                  </React.Fragment>
                  ) : (
                  /* QC Tab Content */
                  <div className="flex-1 overflow-y-auto">
                    <QCSummaryDashboard
                      patient={selectedPatient}
                      qcData={qcData}
                    />
                  </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    };

    // Header Component
    const Header = () => (
      <div className="bg-white border-b border-gray-200 px-4 md:px-6 py-4 shadow-sm">
        <h1 className="text-2xl md:text-3xl font-bold text-gray-900 mb-1">LENS Visualization and Report Generator</h1>
        <p className="text-sm text-gray-600">Multi-patient pMHC prioritization and analysis platform</p>
      </div>
    );

    // Sidebar Component
    const Sidebar = ({ patients, selectedPatient, setSelectedPatient, setSelectedAlleles, setSelectedAntigenSources, sidebarCollapsed, setSidebarCollapsed, viewMode, setViewMode, qcData, selectedGroup, setSelectedGroup }) => {
      const handlePatientClick = (patientId) => {
        setViewMode('patient');
        setSelectedPatient(patientId);
        const patient = patients[patientId];
        if (patient.isMultiGroup && patient.groups.length > 0) {
          // Auto-select first group for multi-group patients
          setSelectedGroup(patient.groups[0]);
          const groupData = patient.groupData[patient.groups[0]];
          setSelectedAlleles(new Set(groupData.alleles));
          setSelectedAntigenSources(new Set(groupData.antigenSources));
        } else {
          setSelectedGroup(null);
          setSelectedAlleles(new Set(patient.alleles));
          setSelectedAntigenSources(new Set(patient.antigenSources));
        }
      };

      const handleGroupClick = (patientId, group) => {
        setViewMode('patient');
        setSelectedPatient(patientId);
        setSelectedGroup(group);
        setPatientTab('pmhc');
        const patient = patients[patientId];
        if (group === 'joint') {
          // Joint analysis uses all data
          setSelectedAlleles(new Set(patient.alleles));
          setSelectedAntigenSources(new Set(patient.antigenSources));
        } else if (patient.groupData && patient.groupData[group]) {
          const groupData = patient.groupData[group];
          setSelectedAlleles(new Set(groupData.alleles));
          setSelectedAntigenSources(new Set(groupData.antigenSources));
        }
      };

      return (
      <div className={`${sidebarCollapsed ? 'w-16' : 'w-72'} bg-white border-r border-gray-200 overflow-y-auto overflow-x-hidden shadow-sm transition-all duration-300 relative flex-shrink-0`}>
        {/* Toggle Button */}
        <button
          onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
          className="absolute top-1/2 -right-4 transform -translate-y-1/2 w-8 h-16 rounded-r-lg border-2 border-l-0 border-indigo-500 bg-white cursor-pointer flex items-center justify-center z-50 shadow-md hover:bg-indigo-50 transition text-indigo-600 font-bold text-lg"
        >
          {sidebarCollapsed ? '>' : '<'}
        </button>

        {sidebarCollapsed ? (
          <div className="py-12 px-2 flex flex-col items-center h-full justify-center">
            <div className="writing-mode-vertical transform rotate-180 text-sm font-bold text-indigo-600 py-4 tracking-wider" style={{ writingMode: 'vertical-rl' }}>
              {selectedPatient}{selectedGroup && selectedGroup !== 'joint' ? ` (${selectedGroup})` : ''}
            </div>
          </div>
        ) : (
          <div className="p-4">
            {/* Global Settings Button */}
            <button
              onClick={() => setViewMode('global-settings')}
              className={`w-full p-3 mb-2 rounded-md cursor-pointer transition flex items-center gap-2 text-sm font-medium ${
                viewMode === 'global-settings'
                  ? 'bg-indigo-600 text-white'
                  : 'bg-gray-100 text-gray-700 hover:bg-gray-200 border border-gray-200'
              }`}
            >
              <Icon name="settings" size={18} />
              <span>Global Settings</span>
            </button>

            {/* Cohort QC Button */}
            <button
              onClick={() => setViewMode('cohort-qc')}
              className={`w-full p-3 mb-4 rounded-md cursor-pointer transition flex items-center gap-2 text-sm font-medium ${
                viewMode === 'cohort-qc'
                  ? 'bg-emerald-600 text-white'
                  : 'bg-gray-100 text-gray-700 hover:bg-gray-200 border border-gray-200'
              }`}
            >
              <Icon name="clipboard-check" size={18} />
              <span>Cohort QC</span>
              {Object.keys(qcData?.patients || {}).length > 0 && (
                <span className={`ml-auto text-xs px-2 py-0.5 rounded-full ${viewMode === 'cohort-qc' ? 'bg-emerald-500' : 'bg-emerald-100 text-emerald-700'}`}>
                  {Object.keys(qcData.patients).length}
                </span>
              )}
            </button>

            {/* Patients */}
            <h3 className="text-base font-semibold mb-3 text-gray-800 border-b-2 border-indigo-500 pb-2">
              Patients ({Object.keys(patients).length})
            </h3>
            {Object.keys(patients).sort().map(patientId => {
              const patient = patients[patientId];
              const isSelected = selectedPatient === patientId && viewMode === 'patient';
              return (
                <div key={patientId} className="mb-2">
                  <button
                    onClick={() => handlePatientClick(patientId)}
                    className={`w-full p-3 rounded-md cursor-pointer transition text-left ${
                      isSelected
                        ? 'bg-indigo-600 text-white'
                        : 'bg-gray-50 text-gray-700 hover:bg-gray-100 border border-gray-200'
                    }`}
                  >
                    <div className="flex items-center justify-between">
                      <div className="text-sm font-semibold mb-0.5">{patientId}</div>
                      {patient.isMultiGroup && (
                        <span className={`text-xs px-1.5 py-0.5 rounded ${isSelected ? 'bg-indigo-500' : 'bg-purple-100 text-purple-700'}`}>
                          {patient.groups.length} groups
                        </span>
                      )}
                    </div>
                    <div className={`text-xs ${isSelected ? 'text-indigo-200' : 'text-gray-500'}`}>
                      {patient.data.length} pMHCs &bull; {patient.alleles.size} alleles
                    </div>
                  </button>

                  {/* Group sub-navigation for multi-group patients */}
                  {isSelected && patient.isMultiGroup && (
                    <div className="ml-3 mt-1 space-y-1 border-l-2 border-indigo-300 pl-2">
                      {patient.groups.map(group => (
                        <button
                          key={group}
                          onClick={() => handleGroupClick(patientId, group)}
                          className={`w-full p-2 text-left text-sm rounded transition ${
                            selectedGroup === group
                              ? 'bg-indigo-100 text-indigo-700 font-medium'
                              : 'text-gray-600 hover:bg-gray-100'
                          }`}
                        >
                          <Icon name="folder" size={14} className="inline mr-1" />
                          {group}
                          <span className="text-xs text-gray-400 ml-1">
                            ({patient.groupData[group]?.data.length || 0})
                          </span>
                        </button>
                      ))}
                      <button
                        onClick={() => handleGroupClick(patientId, 'joint')}
                        className={`w-full p-2 text-left text-sm rounded transition ${
                          selectedGroup === 'joint'
                            ? 'bg-purple-100 text-purple-700 font-medium'
                            : 'text-gray-600 hover:bg-gray-100'
                        }`}
                      >
                        <Icon name="git-compare" size={14} className="inline mr-1" />
                        Joint Analysis
                      </button>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        )}
      </div>
    );
    };

    // Global Settings Component
    const GlobalSettings = ({ topN, setTopN, sortMetric, setSortMetric, globalFormula, setGlobalFormula }) => (
      <div className="max-w-4xl">
        <h2 className="text-xl font-bold text-gray-900 mb-4">Global Settings</h2>
        <div className="bg-white rounded-lg shadow-md p-4 md:p-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1">Default Top N pMHCs</label>
              <p className="text-xs text-gray-500 mb-2">Number of top pMHCs to display (can be overridden per patient)</p>
              <input
                type="number" value={topN} min="1"
                onChange={(e) => { const num = parseInt(e.target.value); if (!isNaN(num) && num >= 1) setTopN(num); }}
                className="w-full px-2 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1">Default Sort Metric</label>
              <p className="text-xs text-gray-500 mb-2">Metric used for sorting and ranking pMHCs</p>
              <select
                value={sortMetric} onChange={(e) => setSortMetric(e.target.value)}
                className="w-full px-2 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white"
              >
                {priorityMetrics.map(m => <option key={m.value} value={m.value}>{m.label}</option>)}
              </select>
            </div>
          </div>
          <div>
            <label className="block text-xs font-medium text-gray-700 mb-1">Custom Prioritization Formula</label>
            <p className="text-xs text-gray-500 mb-2 leading-relaxed">
              Define a custom formula using column names and operators (+, -, *, /, min(), max(), bound1()).
              <br /><code className="bg-gray-100 px-1 py-0.5 rounded text-xs">bound1(priority_score_maximum) * bound1(ccf) + bound1(vaf)</code>
            </p>
            <textarea
              value={globalFormula} onChange={(e) => setGlobalFormula(e.target.value)}
              placeholder="e.g., priority_score_maximum * ccf + vaf"
              className="w-full min-h-24 px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent font-mono resize-y"
            />
          </div>
        </div>
      </div>
    );

    // Patient Controls Component
    const PatientControls = ({
      selectedPatient, patients, topN, sortMetric,
      patientTopN, setPatientTopN, patientSortMetrics, setPatientSortMetrics,
      patientFormulas, setPatientFormulas, globalFormula,
      selectedAntigenSources, toggleAntigenSource,
      selectedAlleles, toggleAllele,
      showAlleleTable, setShowAlleleTable,
      showDataTable, setShowDataTable, generateReport
    }) => {
      const [controlsExpanded, setControlsExpanded] = useState(true);

      if (!selectedPatient || !patients[selectedPatient]) return null;
      const patient = patients[selectedPatient];

      return (
        <div className="bg-white rounded-lg shadow-md p-4 md:p-6 mb-4">
          {/* Collapsible Header */}
          <div className="flex items-center justify-between mb-4">
            <button
              onClick={() => setControlsExpanded(!controlsExpanded)}
              className="flex items-center gap-2 text-sm font-semibold text-gray-800 hover:text-gray-600 transition cursor-pointer"
            >
              <span className={`text-gray-500 transition-transform ${controlsExpanded ? 'rotate-90' : ''}`}></span>
              Sorting Metric, Antigen Sources, and HLA Alleles
            </button>
          </div>

          {controlsExpanded && (
            <>
          {/* Patient Overrides */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 pb-4 border-b border-gray-200">
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1">Top N (Override)</label>
              <input
                type="number"
                value={patientTopN[selectedPatient] !== undefined ? patientTopN[selectedPatient] : ''}
                placeholder={`Default: ${topN}`}
                onChange={(e) => {
                  const val = e.target.value;
                  if (val === '') {
                    const newPatientTopN = {...patientTopN}; delete newPatientTopN[selectedPatient]; setPatientTopN(newPatientTopN);
                  } else {
                    const num = parseInt(val);
                    if (!isNaN(num) && num >= 1) setPatientTopN({...patientTopN, [selectedPatient]: num});
                  }
                }}
                className="w-full px-2 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              />
            </div>
            <div>
              <label className="block text-xs font-medium text-gray-700 mb-1">Sort Metric (Override)</label>
              <select
                value={patientSortMetrics[selectedPatient] || ''}
                onChange={(e) => {
                  if (e.target.value === '') {
                    const newMetrics = {...patientSortMetrics}; delete newMetrics[selectedPatient]; setPatientSortMetrics(newMetrics);
                  } else {
                    setPatientSortMetrics({...patientSortMetrics, [selectedPatient]: e.target.value});
                  }
                }}
                className="w-full px-2 py-1.5 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white"
              >
                <option value="">Use Global: {priorityMetrics.find(m => m.value === sortMetric)?.label}</option>
                {priorityMetrics.map(m => <option key={m.value} value={m.value}>{m.label}</option>)}
              </select>
            </div>
          </div>

          {/* Patient Formula */}
          <div className="mb-4">
            <label className="block text-xs font-medium text-gray-700 mb-1">Custom Formula (Override)</label>
            <textarea
              value={patientFormulas[selectedPatient] || ''}
              onChange={(e) => setPatientFormulas({...patientFormulas, [selectedPatient]: e.target.value})}
              placeholder={globalFormula || "e.g., priority_score_maximum * ccf + vaf"}
              className="w-full min-h-20 px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent font-mono resize-y"
            />
          </div>

          {/* Antigen Sources */}
          <div className="mb-4">
            <label className="block text-xs font-medium text-gray-700 mb-2">
              Antigen Sources ({selectedAntigenSources.size} of {patient.antigenSources.size} selected)
            </label>
            <div className="flex flex-wrap gap-2">
              {Array.from(patient.antigenSources).sort().map(source => {
                const count = patient.data.filter(row => row.antigen_source === source).length;
                const isSelected = selectedAntigenSources.has(source);
                return (
                  <button
                    key={source} onClick={() => toggleAntigenSource(source)}
                    className={`px-3 py-1.5 rounded-full border-2 cursor-pointer text-xs font-semibold transition flex flex-col items-center gap-0.5 ${
                      isSelected
                        ? 'border-indigo-600 bg-indigo-600 text-white'
                        : 'border-gray-300 bg-white text-gray-700 hover:border-indigo-400'
                    }`}
                  >
                    <span>{source}</span>
                    <span className={`text-xs ${isSelected ? 'text-indigo-200' : 'text-gray-500'}`}>{count} pMHCs</span>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Allele Selection */}
          <div className="mb-4">
            <div className="flex justify-between items-center mb-2">
              <label className="text-xs font-medium text-gray-700">
                HLA Alleles ({selectedAlleles.size} of {patient.alleles.size} selected)
              </label>
              <button
                onClick={() => setShowAlleleTable(!showAlleleTable)}
                className="px-3 py-1 bg-white border border-gray-300 rounded-md cursor-pointer text-xs font-medium text-gray-700 flex items-center gap-1 hover:bg-gray-50 transition"
              >
                <Icon name={showAlleleTable ? 'chevron-down' : 'chevron-right'} size={14} />
                {showAlleleTable ? 'Hide' : 'Show'} Allele Table
              </button>
            </div>
            {showAlleleTable && (
              <AlleleTable alleles={patient.alleles} alleleSupport={patient.alleleSupport} selectedAlleles={selectedAlleles} toggleAllele={toggleAllele} />
            )}
          </div>
            </>
          )}

          {/* Action Buttons */}
          <div className="flex gap-2 flex-wrap">
            <button
              onClick={() => setShowDataTable(!showDataTable)}
              className={`px-4 py-2 rounded-md cursor-pointer text-sm font-medium flex items-center gap-2 transition ${
                showDataTable
                  ? 'bg-gray-800 text-white'
                  : 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-50'
              }`}
            >
              <Icon name={showDataTable ? 'chevron-down' : 'chevron-right'} size={16} />
              {showDataTable ? 'Hide' : 'Show'} Data Table
            </button>
            <button
              onClick={generateReport}
              className="px-4 py-2 bg-green-600 text-white rounded-md cursor-pointer text-sm font-medium flex items-center gap-2 hover:bg-green-700 transition"
            >
              <Icon name="download" size={16} />
              Export Report
            </button>
          </div>
        </div>
      );
    };

    // Allele Table Component
    const AlleleTable = ({ alleles, alleleSupport, selectedAlleles, toggleAllele }) => {
      const formatSupport = (support) => {
        if (!support || Object.keys(support).length === 0) return 'N/A';
        return Object.entries(support).map(([tool, sampleTypes]) => {
          const capitalizedTool = tool.toLowerCase() === 'seq2hla' ? 'seq2HLA' : tool.charAt(0).toUpperCase() + tool.slice(1);
          const formattedTypes = Array.from(sampleTypes).map(t => t.replace(/_/g, ' ').split(' ').map(w => w.toUpperCase() === 'DNA' || w.toUpperCase() === 'RNA' ? w.toUpperCase() : w.charAt(0).toUpperCase() + w.slice(1)).join(' ')).join(', ');
          return `${capitalizedTool} (${formattedTypes})`;
        }).join(', ');
      };

      return (
        <div className="bg-gray-50 rounded-md p-3 max-h-96 overflow-y-auto border border-gray-200">
          <table className="w-full border-collapse text-sm">
            <thead>
              <tr className="border-b-2 border-gray-200">
                <th className="py-2 px-2 text-left font-semibold text-gray-700 w-14">Select</th>
                <th className="py-2 px-2 text-left font-semibold text-gray-700 w-36">Allele</th>
                <th className="py-2 px-2 text-left font-semibold text-gray-700">Allele Support</th>
              </tr>
            </thead>
            <tbody>
              {Array.from(alleles).sort().map((allele, idx) => (
                <tr
                  key={allele}
                  onClick={() => toggleAllele(allele)}
                  className={`cursor-pointer hover:bg-gray-100 ${idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}`}
                >
                  <td className="py-2 px-2 text-center">
                    <input
                      type="checkbox"
                      checked={selectedAlleles.has(allele)}
                      onChange={() => {}}
                      className="w-4 h-4 cursor-pointer accent-indigo-600"
                    />
                  </td>
                  <td className="py-2 px-2 font-mono font-semibold text-gray-800 text-xs">{allele}</td>
                  <td className="py-2 px-2 text-gray-500 text-xs">{formatSupport(alleleSupport[allele])}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    };

    // Visualization Panel
    const VisualizationPanel = ({ fullPatientData, topNData, allPatientsData, sortMetric, selectedRow, setSelectedRow, topN, selectedPatient }) => (
      <div className="bg-white rounded-lg shadow-md p-4 md:p-6 mb-4">
        <h3 className="text-base font-semibold text-gray-800 mb-4">Distribution Analysis</h3>

        {/* Histograms */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
          {visMetrics.map(metric => (
            <Histogram key={metric} data={fullPatientData} topNData={topNData} metric={metric} selectedRow={selectedRow} topN={topN} />
          ))}
        </div>

        {/* Scatter Matrix */}
        <h4 className="text-sm font-semibold text-gray-800 mt-6 mb-4">Correlation Matrix</h4>
        <ScatterMatrix data={fullPatientData} topNData={topNData} metrics={visMetrics.slice(0, 4)} selectedRow={selectedRow} setSelectedRow={setSelectedRow} />

        {/* Box Plots */}
        {allPatientsData.length > fullPatientData.length && (
          <>
            <h4 className="text-sm font-semibold text-gray-800 mt-6 mb-4">Cross-Patient Comparison</h4>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {visMetrics.slice(0, 3).map(metric => (
                <BoxPlot key={metric} allData={allPatientsData} metric={metric} selectedPatient={selectedPatient} />
              ))}
            </div>
          </>
        )}
      </div>
    );

    // Histogram Component
    const Histogram = ({ data, topNData, metric, selectedRow, topN }) => {
      const containerRef = useRef();
      const svgRef = useRef();

      // Transform function for TPM (log2)
      const transformValue = (v, m) => {
        const num = parseFloat(v);
        if (isNaN(num)) return NaN;
        if (m === 'tpm') return num > 0 ? Math.log2(num) : NaN;
        return num;
      };

      useEffect(() => {
        if (!data.length || !svgRef.current || !containerRef.current) return;
        const svg = d3.select(svgRef.current);
        svg.selectAll('*').remove();

        // Responsive width based on container
        const containerWidth = containerRef.current.clientWidth || 320;
        const width = Math.max(200, Math.min(containerWidth - 24, 400)); // Account for padding
        const height = Math.round(width * 0.56); // 16:9 aspect ratio
        const margin = { top: 20, right: 20, bottom: 40, left: 50 };

        // Set SVG dimensions
        svg.attr('width', width).attr('height', height);

        const values = data.map(d => transformValue(d[metric], metric)).filter(v => !isNaN(v));
        if (values.length === 0) return;

        const topNSet = new Set(topNData.map(d => `${d.peptide}-${d.allele}`));
        const valueItems = data.map(d => ({ value: transformValue(d[metric], metric), isTopN: topNSet.has(`${d.peptide}-${d.allele}`) })).filter(item => !isNaN(item.value));

        const x = d3.scaleLinear().domain(d3.extent(values)).range([margin.left, width - margin.right]);
        const bins = d3.bin().domain(x.domain()).thresholds(20)(values);

        const binsWithTopN = bins.map((bin, idx) => {
          const isLastBin = idx === bins.length - 1;
          const itemsInBin = valueItems.filter(item => item.value >= bin.x0 && (isLastBin ? item.value <= bin.x1 : item.value < bin.x1));
          return { x0: bin.x0, x1: bin.x1, length: itemsInBin.length, topNCount: itemsInBin.filter(item => item.isTopN).length };
        });

        const y = d3.scaleLinear().domain([0, d3.max(bins, d => d.length)]).range([height - margin.bottom, margin.top]);
        const g = svg.append('g');

        g.selectAll('rect.full').data(binsWithTopN).join('rect').attr('class', 'full')
          .attr('x', d => x(d.x0) + 1).attr('y', d => y(d.length))
          .attr('width', d => Math.max(0, x(d.x1) - x(d.x0) - 2)).attr('height', d => y(0) - y(d.length))
          .attr('fill', '#374151').attr('opacity', 0.6);

        g.selectAll('rect.topn').data(binsWithTopN.filter(d => d.topNCount > 0)).join('rect').attr('class', 'topn')
          .attr('x', d => x(d.x0) + 1).attr('y', d => y(d.topNCount))
          .attr('width', d => Math.max(0, x(d.x1) - x(d.x0) - 2)).attr('height', d => y(0) - y(d.topNCount))
          .attr('fill', '#6366f1').attr('opacity', 0.9);

        if (selectedRow && selectedRow[metric]) {
          const selectedValue = transformValue(selectedRow[metric], metric);
          if (!isNaN(selectedValue)) {
            g.append('line').attr('x1', x(selectedValue)).attr('x2', x(selectedValue))
              .attr('y1', margin.top).attr('y2', height - margin.bottom)
              .attr('stroke', '#dc2626').attr('stroke-width', 3).attr('stroke-dasharray', '5,5');
          }
        }

        g.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(x).ticks(5)).style('font-size', '10px');
        g.append('g').attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y).ticks(5)).style('font-size', '10px');
      }, [data, topNData, metric, selectedRow, topN]);

      const label = metric === 'tpm' ? 'LOG2(TPM)' : metric.includes('mhcflurry_2.1.1.aff') ? 'MHCFLURRY AFFINITY' : metric.includes('mhcflurry_2.1.1.pres') ? 'MHCFLURRY PRESENTATION SCORE' : metric.replace(/_/g, ' ').toUpperCase();

      return (
        <div ref={containerRef} className="bg-gray-50 rounded-md p-3 border border-gray-200">
          <div className="text-xs font-semibold text-gray-700 mb-1">{label}</div>
          <div className="text-xs text-gray-500 mb-2 flex items-center gap-3">
            <span className="flex items-center gap-1">
              <div className="w-3 h-3 bg-indigo-500 rounded-sm opacity-90" /> Top {topN}
            </span>
            <span className="flex items-center gap-1">
              <div className="w-3 h-3 bg-gray-600 rounded-sm opacity-60" /> Full Distribution
            </span>
          </div>
          <svg ref={svgRef} className="w-full" style={{ maxWidth: '400px', height: 'auto', aspectRatio: '16/9' }} />
        </div>
      );
    };

    // Scatter Matrix Component
    const ScatterMatrix = ({ data, topNData, metrics, selectedRow, setSelectedRow }) => (
      <div className="bg-gray-50 p-4 rounded-md border border-gray-200 overflow-x-auto">
        <div className="flex justify-center min-w-fit">
          <table className="border-collapse">
            <tbody>
              {metrics.map((metricY, i) => (
                <tr key={`row-${i}`}>
                  {metrics.map((metricX, j) => (
                    <td key={`cell-${i}-${j}`} className="p-0 bg-white border border-gray-200" style={{ width: 'clamp(120px, 15vw, 200px)', height: 'clamp(120px, 15vw, 200px)' }}>
                      {i === j ? (
                        <div className="flex items-center justify-center h-full text-xs font-semibold text-gray-700 text-center p-2">
                          {metricX.includes('mhcflurry_2.1.1.aff') ? 'AFFINITY (nM)' : metricX.includes('mhcflurry_2.1.1.pres') ? 'PRESENTATION SCORE' : metricX.replace(/_/g, ' ').toUpperCase()}
                        </div>
                      ) : (
                        <ScatterPlot data={data} topNData={topNData} metricX={metricX} metricY={metricY} selectedRow={selectedRow} setSelectedRow={setSelectedRow} />
                      )}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    );

    // Scatter Plot Component
    const ScatterPlot = ({ data, topNData, metricX, metricY, selectedRow, setSelectedRow }) => {
      const svgRef = useRef();

      useEffect(() => {
        if (!data.length || !svgRef.current) return;
        const svg = d3.select(svgRef.current);
        svg.selectAll('*').remove();

        // Get actual dimensions from the SVG element
        const rect = svgRef.current.getBoundingClientRect();
        const width = Math.max(120, rect.width || 200);
        const height = Math.max(120, rect.height || 200);
        svg.attr('width', width).attr('height', height);
        const margin = { top: 10, right: 10, bottom: 30, left: 40 };

        const points = data.map(d => ({ x: parseFloat(d[metricX]), y: parseFloat(d[metricY]), data: d })).filter(p => !isNaN(p.x) && !isNaN(p.y));
        if (points.length === 0) return;

        const topNSet = new Set(topNData.filter(d => !isNaN(parseFloat(d[metricX])) && !isNaN(parseFloat(d[metricY]))).map(d => `${d.peptide}-${d.allele}`));

        const x = d3.scaleLinear().domain(d3.extent(points, d => d.x)).range([margin.left, width - margin.right]);
        const y = d3.scaleLinear().domain(d3.extent(points, d => d.y)).range([height - margin.bottom, margin.top]);
        const g = svg.append('g');

        const nonTopN = points.filter(p => !topNSet.has(`${p.data.peptide}-${p.data.allele}`));
        const topNPoints = points.filter(p => topNSet.has(`${p.data.peptide}-${p.data.allele}`));

        g.selectAll('circle.nontop').data(nonTopN).join('circle').attr('class', 'nontop')
          .attr('cx', d => x(d.x)).attr('cy', d => y(d.y))
          .attr('r', d => selectedRow && d.data.peptide === selectedRow.peptide && d.data.allele === selectedRow.allele ? 6 : 3)
          .attr('fill', d => selectedRow && d.data.peptide === selectedRow.peptide && d.data.allele === selectedRow.allele ? '#dc2626' : '#374151')
          .attr('opacity', 0.3).style('cursor', 'pointer').on('click', (event, d) => setSelectedRow(d.data));

        g.selectAll('circle.topn').data(topNPoints).join('circle').attr('class', 'topn')
          .attr('cx', d => x(d.x)).attr('cy', d => y(d.y))
          .attr('r', d => selectedRow && d.data.peptide === selectedRow.peptide && d.data.allele === selectedRow.allele ? 6 : 3.5)
          .attr('fill', d => selectedRow && d.data.peptide === selectedRow.peptide && d.data.allele === selectedRow.allele ? '#dc2626' : '#6366f1')
          .attr('opacity', 0.7).style('cursor', 'pointer').on('click', (event, d) => setSelectedRow(d.data));

        g.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(x).ticks(4)).style('font-size', '9px');
        g.append('g').attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y).ticks(4)).style('font-size', '9px');
      }, [data, topNData, metricX, metricY, selectedRow, setSelectedRow]);

      return <svg ref={svgRef} className="w-full h-full" style={{ minWidth: '120px', minHeight: '120px' }} />;
    };

    // Box Plot Component
    const BoxPlot = ({ allData, metric, selectedPatient }) => {
      const svgRef = useRef();
      const containerRef = useRef();
      const [containerWidth, setContainerWidth] = useState(400);

      useEffect(() => {
        if (containerRef.current) {
          const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
              setContainerWidth(entry.contentRect.width - 24); // account for padding
            }
          });
          resizeObserver.observe(containerRef.current);
          return () => resizeObserver.disconnect();
        }
      }, []);

      useEffect(() => {
        if (!allData.length || !svgRef.current) return;
        const svg = d3.select(svgRef.current);
        svg.selectAll('*').remove();

        const width = Math.max(400, containerWidth);
        const height = 200;
        const margin = { top: 20, right: 20, bottom: 70, left: 50 };

        const byPatient = d3.group(allData, d => d.patientId);
        let patientStats = Array.from(byPatient, ([patientId, data]) => {
          const values = data.map(d => parseFloat(d[metric])).filter(v => !isNaN(v)).sort(d3.ascending);
          if (values.length === 0) return null;
          return { patientId, q1: d3.quantile(values, 0.25), median: d3.quantile(values, 0.5), q3: d3.quantile(values, 0.75), min: values[0], max: values[values.length - 1], isSelected: patientId === selectedPatient };
        }).filter(d => d !== null);

        if (patientStats.length === 0) return;

        // Sort by median descending
        patientStats = patientStats.sort((a, b) => b.median - a.median);

        const x = d3.scaleBand().domain(patientStats.map(d => d.patientId)).range([margin.left, width - margin.right]).padding(0.4);
        const y = d3.scaleLinear().domain([d3.min(patientStats, d => d.min), d3.max(patientStats, d => d.max)]).range([height - margin.bottom, margin.top]);
        const g = svg.append('g');

        patientStats.forEach(d => {
          const xPos = x(d.patientId) + x.bandwidth() / 2;
          const boxWidth = x.bandwidth() * 0.7;
          const color = d.isSelected ? '#dc2626' : '#6366f1';

          g.append('line').attr('x1', xPos).attr('x2', xPos).attr('y1', y(d.min)).attr('y2', y(d.q1)).attr('stroke', d.isSelected ? '#dc2626' : '#6b7280').attr('stroke-width', d.isSelected ? 2 : 1);
          g.append('line').attr('x1', xPos).attr('x2', xPos).attr('y1', y(d.q3)).attr('y2', y(d.max)).attr('stroke', d.isSelected ? '#dc2626' : '#6b7280').attr('stroke-width', d.isSelected ? 2 : 1);
          g.append('rect').attr('x', xPos - boxWidth / 2).attr('y', y(d.q3)).attr('width', boxWidth).attr('height', y(d.q1) - y(d.q3)).attr('fill', color).attr('opacity', d.isSelected ? 0.9 : 0.7).attr('stroke', d.isSelected ? '#dc2626' : '#6b7280').attr('stroke-width', d.isSelected ? 2 : 1);
          g.append('line').attr('x1', xPos - boxWidth / 2).attr('x2', xPos + boxWidth / 2).attr('y1', y(d.median)).attr('y2', y(d.median)).attr('stroke', d.isSelected ? '#991b1b' : '#1f2937').attr('stroke-width', d.isSelected ? 3 : 2);
        });

        g.append('g').attr('transform', `translate(0,${height - margin.bottom})`).call(d3.axisBottom(x)).selectAll('text').attr('transform', 'rotate(-45)').style('text-anchor', 'end').style('font-size', '10px').style('font-weight', d => patientStats.find(p => p.patientId === d)?.isSelected ? 700 : 400).style('fill', d => patientStats.find(p => p.patientId === d)?.isSelected ? '#dc2626' : '#374151');
        g.append('g').attr('transform', `translate(${margin.left},0)`).call(d3.axisLeft(y).ticks(5)).style('font-size', '10px');
      }, [allData, metric, selectedPatient, containerWidth]);

      const label = metric === 'tpm' ? 'LOG2(TPM)' : metric.includes('mhcflurry_2.1.1.aff') ? 'MHCFLURRY AFFINITY' : metric.includes('mhcflurry_2.1.1.pres') ? 'MHCFLURRY PRESENTATION SCORE' : metric.replace(/_/g, ' ').toUpperCase();

      return (
        <div ref={containerRef} className="bg-white rounded-md p-3 border border-gray-200">
          <div className="text-xs font-semibold text-gray-700 mb-2">{label}</div>
          <svg ref={svgRef} width={Math.max(400, containerWidth)} height="200" />
        </div>
      );
    };

    // Data Table Component
    const DataTable = ({ data, selectedRow, setSelectedRow, hasCustomFormula }) => {
      const [sortColumn, setSortColumn] = useState(null);
      const [sortDirection, setSortDirection] = useState('desc');

      const sortedData = useMemo(() => {
        if (!sortColumn) return data;
        return [...data].sort((a, b) => {
          const aVal = parseFloat(a[sortColumn]) || 0;
          const bVal = parseFloat(b[sortColumn]) || 0;
          return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
        });
      }, [data, sortColumn, sortDirection]);

      const handleSort = (column) => {
        if (sortColumn === column) setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
        else { setSortColumn(column); setSortDirection('desc'); }
      };

      const baseColumns = [
        { key: 'peptide', label: 'Peptide' }, { key: 'allele', label: 'Allele' },
        { key: 'priority_score_maximum', label: 'Max Priority Score' },
        { key: 'mhcflurry_2.1.1.aff', label: 'MHCFlurry Aff' },
        { key: 'ccf', label: 'CCF' }, { key: 'vaf', label: 'VAF' }, { key: 'tpm', label: 'Log2(TPM)', transform: v => { const num = parseFloat(v); return (!isNaN(num) && num > 0) ? Math.log2(num) : null; } },
        { key: 'antigen_source', label: 'Source' },
      ];

      // Add custom score column if formula is active
      const columns = hasCustomFormula
        ? [{ key: 'custom_score', label: 'Custom Score' }, ...baseColumns]
        : baseColumns;

      const formatValue = (col, value) => {
        if (col.key === 'peptide' || col.key === 'allele' || col.key === 'antigen_source') return value || 'N/A';
        if (value === null || value === undefined || value === '' || value === 'NA') return 'N/A';
        // Apply transform if available (e.g., log2 for TPM)
        const transformedValue = col.transform ? col.transform(value) : parseFloat(value);
        return (transformedValue === null || isNaN(transformedValue)) ? 'N/A' : transformedValue.toFixed(3);
      };

      return (
        <div className="bg-white rounded-lg shadow-md p-4 md:p-6 mb-4 overflow-x-auto">
          <h3 className="text-base font-semibold text-gray-800 mb-4">Data Table</h3>
          <table className="w-full border-collapse text-sm">
            <thead>
              <tr className="bg-gray-50">
                {columns.map(col => (
                  <th
                    key={col.key}
                    onClick={() => handleSort(col.key)}
                    className={`py-3 px-2 text-left font-semibold cursor-pointer border-b-2 whitespace-nowrap hover:bg-gray-100 transition ${
                      col.key === 'custom_score'
                        ? 'bg-indigo-100 text-indigo-800 border-indigo-300'
                        : 'text-gray-700 border-gray-200'
                    }`}
                  >
                    {col.label} {sortColumn === col.key && (sortDirection === 'asc' ? '' : '')}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {sortedData.map((row, idx) => {
                const isSelected = selectedRow?.peptide === row.peptide && selectedRow?.allele === row.allele;
                return (
                  <tr key={`${row.peptide}-${row.allele}-${idx}`} onClick={() => setSelectedRow(row)} className={`cursor-pointer hover:bg-gray-100 transition ${isSelected ? 'bg-red-50' : idx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}`}>
                    {columns.map(col => (
                      <td
                        key={col.key}
                        className={`py-2 px-2 border-b border-gray-200 ${
                          col.key === 'peptide' || col.key === 'allele' ? 'font-mono text-xs' : ''
                        } ${col.key === 'custom_score' ? 'bg-indigo-50 font-semibold text-indigo-800' : ''}`}
                      >
                        {formatValue(col, row[col.key])}
                      </td>
                    ))}
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      );
    };

    // Cohort QC View Component
    const CohortQCView = ({ qcData, patients, manifestData }) => {
      const patientIds = Object.keys(patients).sort();
      const hasMultiGroup = manifestData?.has_multi_group;
      const allGroups = manifestData?.all_groups || ['default'];
      const qcPatients = qcData?.patients || {};
      const hasQcData = Object.keys(qcPatients).length > 0;

      if (patientIds.length === 0) {
        return (
          <div className="bg-white rounded-lg shadow-md p-8 text-center">
            <Icon name="clipboard-check" size={48} color="#6b7280" className="mx-auto mb-4" />
            <h2 className="text-xl font-semibold text-gray-800 mb-2">No Data Available</h2>
            <p className="text-gray-600">Load patient data to view cohort summary.</p>
          </div>
        );
      }

      // Count QC tools per patient
      const getToolCount = (patientId) => {
        const patQc = qcPatients[patientId];
        if (!patQc) return 0;
        let count = 0;
        for (const runDir of Object.values(patQc)) {
          count += Object.keys(runDir).length;
        }
        return count;
      };

      return (
        <div className="space-y-6">
          <div className="bg-white rounded-lg shadow-md p-6">
            <h2 className="text-xl font-semibold text-gray-800 mb-4 flex items-center gap-2">
              <Icon name="clipboard-check" size={24} />
              Cohort Summary{hasMultiGroup ? ' (Multi-Group)' : ''}
            </h2>
            <p className="text-sm text-gray-600 mb-6">
              Overview of {patientIds.length} patients{hasMultiGroup ? ` across ${allGroups.length} groups: ${allGroups.join(', ')}` : ''}.
            </p>

            <div className="overflow-x-auto">
              <table className="w-full text-sm border-collapse">
                <thead>
                  <tr className="bg-gray-50">
                    <th className="text-left py-2 px-3 font-semibold text-gray-700 border-b">Patient</th>
                    {hasMultiGroup ? (
                      allGroups.map(group => (
                        <th key={group} colSpan={2} className="text-center py-2 px-3 font-semibold text-gray-700 border-b border-l bg-purple-50">{group}</th>
                      ))
                    ) : (
                      <>
                        <th className="text-center py-2 px-3 font-semibold text-gray-700 border-b">pMHCs</th>
                        <th className="text-center py-2 px-3 font-semibold text-gray-700 border-b">Alleles</th>
                        <th className="text-center py-2 px-3 font-semibold text-gray-700 border-b">Sources</th>
                      </>
                    )}
                    {hasQcData && (
                      <th className="text-center py-2 px-3 font-semibold text-gray-700 border-b">QC Tools</th>
                    )}
                  </tr>
                  {hasMultiGroup && (
                    <tr className="bg-gray-50">
                      <th></th>
                      {allGroups.map(group => (
                        <React.Fragment key={group}>
                          <th className="text-center py-1 px-2 text-xs font-medium text-gray-600 border-b border-l">pMHCs</th>
                          <th className="text-center py-1 px-2 text-xs font-medium text-gray-600 border-b">Alleles</th>
                        </React.Fragment>
                      ))}
                      {hasQcData && <th></th>}
                    </tr>
                  )}
                </thead>
                <tbody>
                  {patientIds.map(patientId => {
                    const patient = patients[patientId];
                    const toolCount = getToolCount(patientId);
                    return (
                      <tr key={patientId} className="border-b hover:bg-gray-50">
                        <td className="py-2 px-3 font-medium">
                          {patientId}
                          {patient.isMultiGroup && (
                            <span className="ml-2 text-xs px-1.5 py-0.5 bg-purple-100 text-purple-700 rounded">{patient.groups.length}g</span>
                          )}
                        </td>
                        {hasMultiGroup ? (
                          allGroups.map(group => {
                            const hasGroup = patient.isMultiGroup ? patient.groups.includes(group) : group === 'default' || group === allGroups[0];
                            const groupData = patient.isMultiGroup ? patient.groupData?.[group] : patient;
                            if (!hasGroup || !groupData) {
                              return (
                                <React.Fragment key={group}>
                                  <td className="py-2 px-2 text-center text-gray-300 border-l">-</td>
                                  <td className="py-2 px-2 text-center text-gray-300">-</td>
                                </React.Fragment>
                              );
                            }
                            return (
                              <React.Fragment key={group}>
                                <td className="py-2 px-2 text-center border-l">{groupData.data?.length || 0}</td>
                                <td className="py-2 px-2 text-center">{groupData.alleles?.size || 0}</td>
                              </React.Fragment>
                            );
                          })
                        ) : (
                          <>
                            <td className="py-2 px-3 text-center">{patient.data.length}</td>
                            <td className="py-2 px-3 text-center">{patient.alleles.size}</td>
                            <td className="py-2 px-3 text-center">{patient.antigenSources.size}</td>
                          </>
                        )}
                        {hasQcData && (
                          <td className="py-2 px-3 text-center">
                            {toolCount > 0 ? (
                              <span className="text-xs px-2 py-0.5 bg-green-100 text-green-700 rounded">{toolCount} tools</span>
                            ) : (
                              <span className="text-xs px-2 py-0.5 bg-gray-100 text-gray-500 rounded">N/A</span>
                            )}
                          </td>
                        )}
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      );
    };

    // Format a numeric value for display
    const formatQcValue = (value) => {
      if (value === null || value === undefined) return '-';
      if (typeof value === 'number') {
        if (Number.isInteger(value) && Math.abs(value) > 9999) return value.toLocaleString();
        if (typeof value === 'number' && !Number.isInteger(value)) {
          if (Math.abs(value) < 0.001 && value !== 0) return value.toExponential(2);
          return parseFloat(value.toPrecision(6)).toString();
        }
        return value.toLocaleString();
      }
      return String(value);
    };

    // QC Metrics Table - displays key-value pairs from a parsed tool
    const QCMetricsTable = ({ data, title }) => {
      if (!data || typeof data !== 'object') return null;
      const entries = Object.entries(data).filter(([k, v]) => v !== null && v !== undefined && v !== '');
      if (entries.length === 0) return null;

      return (
        <div>
          {title && <h4 className="text-sm font-medium text-gray-700 mb-2">{title}</h4>}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
            {entries.map(([key, value]) => (
              <div key={key} className="bg-gray-50 px-3 py-2 rounded text-sm">
                <div className="text-xs text-gray-500 truncate" title={key}>{key}</div>
                <div className="font-medium text-gray-800 truncate" title={String(value)}>{formatQcValue(value)}</div>
              </div>
            ))}
          </div>
        </div>
      );
    };

    // QC Tool Section - collapsible section for a single QC tool
    const QCToolSection = ({ toolName, toolData, patientId }) => {
      const [expanded, setExpanded] = useState(false);
      const label = toolData.label || toolName.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
      const data = toolData.data;
      const files = toolData.files || [];
      const hasPdfs = files.some(f => f.type === 'pdf');
      const hasHtml = files.some(f => f.type === 'html');
      const hasData = data && (Array.isArray(data) ? data.length > 0 : Object.keys(data).length > 0);

      // Tool icon mapping
      const iconMap = {
        samtools_stats: 'bar-chart-2',
        fastp: 'filter',
        qualimap_bamqc: 'align-left',
        qualimap_rnaseq: 'align-left',
        picard2_collect_rna_seq_metrics: 'file-text',
        star_map: 'star',
        bcftools_stats: 'git-branch',
        somalier: 'users',
        whatshap: 'link',
        gatk4_merge_mutect_stats: 'activity',
        parse_lohhla: 'shield',
        lohhla: 'shield',
        igv_reports: 'eye',
        cnvkit_diagram: 'image',
        cnvkit_scatter: 'image',
        lenstools_snv_funnel: 'filter',
        lenstools_indel_funnel: 'filter',
        lenstools_splice_funnel: 'filter',
        lenstools_fusion_funnel: 'filter',
      };
      const icon = iconMap[toolName] || 'file-text';

      return (
        <div className="border border-gray-200 rounded-lg">
          <button
            onClick={() => setExpanded(!expanded)}
            className="w-full p-3 flex items-center justify-between text-left hover:bg-gray-50 transition"
          >
            <div className="flex items-center gap-2">
              <Icon name={icon} size={18} className="text-gray-600" />
              <span className="font-medium text-gray-800 text-sm">{label}</span>
              {hasData && <span className="text-xs px-1.5 py-0.5 bg-blue-100 text-blue-700 rounded">data</span>}
              {hasPdfs && <span className="text-xs px-1.5 py-0.5 bg-orange-100 text-orange-700 rounded">PDF</span>}
              {hasHtml && <span className="text-xs px-1.5 py-0.5 bg-purple-100 text-purple-700 rounded">HTML</span>}
            </div>
            <Icon name={expanded ? 'chevron-up' : 'chevron-down'} size={18} className="text-gray-500" />
          </button>

          {expanded && (
            <div className="p-4 pt-0 border-t border-gray-200 space-y-4">
              {/* Parsed data display */}
              {hasData && toolName === 'somalier' && data.samples && (
                <div>
                  <h4 className="text-sm font-medium text-gray-700 mb-2">Sample Statistics</h4>
                  <div className="overflow-x-auto">
                    <table className="w-full text-xs border-collapse">
                      <thead>
                        <tr className="bg-gray-50">
                          {['sample_id', 'gt_depth_mean', 'gt_depth_sd', 'n_hom_ref', 'n_het', 'n_hom_alt', 'ab_mean'].map(col => (
                            <th key={col} className="py-1 px-2 text-left font-medium border-b">{col}</th>
                          ))}
                        </tr>
                      </thead>
                      <tbody>
                        {data.samples.map((s, i) => (
                          <tr key={i} className="border-b">
                            <td className="py-1 px-2 font-medium">{s.sample_id}</td>
                            <td className="py-1 px-2">{formatQcValue(s.gt_depth_mean)}</td>
                            <td className="py-1 px-2">{formatQcValue(s.gt_depth_sd)}</td>
                            <td className="py-1 px-2">{formatQcValue(s.n_hom_ref)}</td>
                            <td className="py-1 px-2">{formatQcValue(s.n_het)}</td>
                            <td className="py-1 px-2">{formatQcValue(s.n_hom_alt)}</td>
                            <td className="py-1 px-2">{formatQcValue(s.ab_mean)}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                  {data.pairs && data.pairs.length > 0 && (
                    <div className="mt-3">
                      <h4 className="text-sm font-medium text-gray-700 mb-2">Pairwise Relatedness</h4>
                      <div className="overflow-x-auto">
                        <table className="w-full text-xs border-collapse">
                          <thead>
                            <tr className="bg-gray-50">
                              {['sample_a', 'sample_b', 'relatedness', 'ibs0', 'ibs2', 'hom_concordance'].map(col => (
                                <th key={col} className="py-1 px-2 text-left font-medium border-b">{col}</th>
                              ))}
                            </tr>
                          </thead>
                          <tbody>
                            {data.pairs.map((p, i) => (
                              <tr key={i} className="border-b">
                                <td className="py-1 px-2 font-medium">{p.sample_a?.split('-').pop()}</td>
                                <td className="py-1 px-2 font-medium">{p.sample_b?.split('-').pop()}</td>
                                <td className="py-1 px-2">
                                  <span className={`px-1.5 py-0.5 rounded text-xs ${p.relatedness >= 0.9 ? 'bg-green-100 text-green-800' : p.relatedness >= 0.5 ? 'bg-yellow-100 text-yellow-800' : 'bg-red-100 text-red-800'}`}>
                                    {formatQcValue(p.relatedness)}
                                  </span>
                                </td>
                                <td className="py-1 px-2">{formatQcValue(p.ibs0)}</td>
                                <td className="py-1 px-2">{formatQcValue(p.ibs2)}</td>
                                <td className="py-1 px-2">{formatQcValue(p.hom_concordance)}</td>
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </div>
                  )}
                </div>
              )}

              {hasData && toolName === 'whatshap' && data.stats && (
                <div>
                  <h4 className="text-sm font-medium text-gray-700 mb-2">Phasing Summary</h4>
                  {data.stats.map((s, i) => (
                    <div key={i} className="mb-2">
                      <div className="text-xs text-gray-500 mb-1">{s.file}</div>
                      <div className="grid grid-cols-2 md:grid-cols-4 gap-2">
                        {['variants', 'phased', 'unphased', 'blocks', 'heterozygous_variants', 'phased_fraction'].map(key => (
                          s.summary[key] !== undefined && (
                            <div key={key} className="bg-gray-50 px-2 py-1 rounded text-sm">
                              <div className="text-xs text-gray-500">{key}</div>
                              <div className="font-medium">{formatQcValue(s.summary[key])}</div>
                            </div>
                          )
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {hasData && toolName === 'lohhla' && data.predictions && (
                <div>
                  <h4 className="text-sm font-medium text-gray-700 mb-2">HLA Loss Predictions</h4>
                  <div className="overflow-x-auto">
                    <table className="w-full text-xs border-collapse">
                      <thead>
                        <tr className="bg-gray-50">
                          {['region', 'HLA_A_type1', 'HLA_A_type2', 'HLA_type1copyNum_withBAF', 'HLA_type2copyNum_withBAF', 'PVal_unique', 'LossAllele', 'KeptAllele'].map(col => (
                            <th key={col} className="py-1 px-2 text-left font-medium border-b whitespace-nowrap">{col}</th>
                          ))}
                        </tr>
                      </thead>
                      <tbody>
                        {data.predictions.map((r, i) => (
                          <tr key={i} className="border-b">
                            <td className="py-1 px-2">{r.region?.split('.').pop()}</td>
                            <td className="py-1 px-2">{r.HLA_A_type1}</td>
                            <td className="py-1 px-2">{r.HLA_A_type2}</td>
                            <td className="py-1 px-2">{formatQcValue(r.HLA_type1copyNum_withBAF)}</td>
                            <td className="py-1 px-2">{formatQcValue(r.HLA_type2copyNum_withBAF)}</td>
                            <td className="py-1 px-2">
                              <span className={`px-1.5 py-0.5 rounded ${r.PVal_unique < 0.05 ? 'bg-red-100 text-red-800' : 'bg-gray-100'}`}>
                                {formatQcValue(r.PVal_unique)}
                              </span>
                            </td>
                            <td className="py-1 px-2 text-red-700">{r.LossAllele}</td>
                            <td className="py-1 px-2 text-green-700">{r.KeptAllele}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {hasData && toolName === 'parse_lohhla' && Array.isArray(data) && (
                <div>
                  <h4 className="text-sm font-medium text-gray-700 mb-2">LOHHLA Loss Summary</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                    {data.map((r, i) => (
                      <div key={i} className="flex items-center gap-3 bg-gray-50 px-3 py-2 rounded">
                        <span className="font-medium text-sm">{r.allele}</span>
                        <span className={`text-xs px-2 py-0.5 rounded ${r.lohhla_allele_loss_pval < 0.05 ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'}`}>
                          p = {formatQcValue(r.lohhla_allele_loss_pval)}
                        </span>
                        {r.lohhla_allele_loss_pval < 0.05 && (
                          <span className="text-xs text-red-600 font-medium">LOH</span>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {hasData && toolName === 'seq2hla' && Array.isArray(data) && (
                <div>
                  <h4 className="text-sm font-medium text-gray-700 mb-2">HLA Class I Typing (RNA)</h4>
                  <div className="overflow-x-auto">
                    <table className="w-full text-sm border-collapse">
                      <thead>
                        <tr className="bg-gray-50">
                          <th className="py-2 px-3 text-left font-medium border-b">Locus</th>
                          <th className="py-2 px-3 text-left font-medium border-b">Allele 1</th>
                          <th className="py-2 px-3 text-center font-medium border-b">Confidence</th>
                          <th className="py-2 px-3 text-left font-medium border-b">Allele 2</th>
                          <th className="py-2 px-3 text-center font-medium border-b">Confidence</th>
                        </tr>
                      </thead>
                      <tbody>
                        {data.map((r, i) => (
                          <tr key={i} className="border-b">
                            <td className="py-2 px-3 font-medium">HLA-{r.locus}</td>
                            <td className="py-2 px-3">
                              <span className="px-2 py-0.5 bg-blue-100 text-blue-800 rounded text-xs font-medium">{r.allele1}</span>
                            </td>
                            <td className="py-2 px-3 text-center text-xs">{formatQcValue(r.confidence1)}</td>
                            <td className="py-2 px-3">
                              <span className="px-2 py-0.5 bg-blue-100 text-blue-800 rounded text-xs font-medium">{r.allele2}</span>
                            </td>
                            <td className="py-2 px-3 text-center text-xs">{formatQcValue(r.confidence2)}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {/* Generic metrics display for standard tools */}
              {hasData && !['somalier', 'whatshap', 'lohhla', 'parse_lohhla', 'seq2hla'].includes(toolName) && (
                (() => {
                  // Check if data is nested (multiple files: {filename: {metrics}})
                  const firstVal = Object.values(data)[0];
                  const isNested = typeof firstVal === 'object' && firstVal !== null && !Array.isArray(firstVal);
                  if (isNested) {
                    return Object.entries(data).map(([fname, metrics]) => (
                      <QCMetricsTable key={fname} data={metrics} title={fname} />
                    ));
                  }
                  return <QCMetricsTable data={data} />;
                })()
              )}

              {/* PDF embeds */}
              {files.filter(f => f.type === 'pdf').map((f, i) => (
                <div key={i}>
                  <h4 className="text-sm font-medium text-gray-700 mb-2">{f.name}</h4>
                  <iframe
                    src={`${API_BASE}/api/qc-file?path=${encodeURIComponent(f.path)}`}
                    className="w-full border border-gray-200 rounded"
                    style={{ height: '500px' }}
                    title={f.name}
                  />
                </div>
              ))}

              {/* HTML links (IGV reports, qualimap reports) */}
              {files.filter(f => f.type === 'html').map((f, i) => (
                <div key={i}>
                  <a
                    href={`${API_BASE}/api/qc-file?path=${encodeURIComponent(f.path)}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="inline-flex items-center gap-2 text-sm text-indigo-600 hover:text-indigo-800 underline"
                  >
                    <Icon name="external-link" size={14} />
                    Open {f.name} in new tab
                  </a>
                </div>
              ))}

              {!hasData && files.length === 0 && (
                <p className="text-sm text-gray-500">No parsable data found for this tool.</p>
              )}
            </div>
          )}
        </div>
      );
    };

    // Helper to format summary metric values
    const formatSummaryValue = (value, format) => {
      if (value === null || value === undefined) return '-';
      switch (format) {
        case 'int':
          return typeof value === 'number' ? value.toLocaleString() : String(value);
        case 'pct':
          return typeof value === 'number' ? (value * 100).toFixed(1) + '%' : String(value);
        case 'pct_raw':
          return typeof value === 'number' ? value.toFixed(1) + '%' : String(value);
        case 'sci':
          return typeof value === 'number' ? value.toExponential(2) : String(value);
        case 'float':
          return typeof value === 'number' ? value.toFixed(2) : String(value);
        case 'str':
          return String(value);
        default:
          return formatQcValue(value);
      }
    };

    // QC Summary Dashboard - curated per-sample metrics
    const QCSummaryDashboard = ({ patient, qcData }) => {
      const [showInDepth, setShowInDepth] = useState(false);
      const summary = qcData?.summaries?.[patient];
      const patientData = qcData?.patients?.[patient];

      if (!summary || (!summary.samples?.length && !summary.multi_sample?.length)) {
        return (
          <div className="bg-white rounded-lg shadow-md p-8 text-center">
            <Icon name="clipboard-check" size={48} color="#6b7280" className="mx-auto mb-4" />
            <h2 className="text-xl font-semibold text-gray-800 mb-2">No QC Data for {patient}</h2>
            <p className="text-gray-600">
              Quality control metrics are not available for this patient.
            </p>
          </div>
        );
      }

      const { groups, groups_source, shared_samples, samples, multi_sample, files } = summary;
      const hasGroups = groups && groups.length > 0;

      // Group samples and multi-sample entries by group
      const renderSampleCard = (sample) => {
        const categories = {};
        (sample.metrics || []).forEach(m => {
          if (!categories[m.category]) categories[m.category] = [];
          categories[m.category].push(m);
        });

        const typeColors = {
          'Tumor DNA': 'border-red-200 bg-red-50',
          'Tumor RNA': 'border-orange-200 bg-orange-50',
          'Normal DNA': 'border-blue-200 bg-blue-50',
          'Control RNA': 'border-green-200 bg-green-50',
        };
        const borderClass = typeColors[sample.label] || 'border-gray-200 bg-gray-50';

        return (
          <div key={sample.run_dir} className={`border rounded-lg p-4 ${borderClass}`}>
            <div className="flex items-center justify-between mb-3">
              <h4 className="font-semibold text-gray-800">{sample.label}</h4>
              <span className="text-xs text-gray-500">{sample.run_ids}</span>
            </div>
            {Object.entries(categories).map(([cat, metrics]) => (
              <div key={cat} className="mb-3 last:mb-0">
                <div className="text-xs font-medium text-gray-500 mb-1.5">{cat}</div>
                <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                  {metrics.map((m, i) => (
                    <div key={i} className="bg-white px-3 py-2 rounded shadow-sm">
                      <div className="text-xs text-gray-500">{m.label}</div>
                      <div className="font-semibold text-gray-800 text-sm">{formatSummaryValue(m.value, m.format)}</div>
                    </div>
                  ))}
                </div>
              </div>
            ))}
            {sample.hla_typing && (
              <div className="mt-3">
                <div className="text-xs font-medium text-gray-500 mb-1.5">HLA Typing (seq2HLA)</div>
                <div className="flex flex-wrap gap-2">
                  {sample.hla_typing.map((r, i) => (
                    <div key={i} className="bg-white px-3 py-1.5 rounded shadow-sm text-sm">
                      <span className="font-medium text-gray-700">HLA-{r.locus}:</span>{' '}
                      <span className="px-1.5 py-0.5 bg-blue-100 text-blue-800 rounded text-xs font-medium">{r.allele1}</span>
                      {r.confidence1 != null && <span className="text-xs text-gray-400 ml-1">(p={r.confidence1.toFixed(2)})</span>}
                      {' / '}
                      <span className="px-1.5 py-0.5 bg-blue-100 text-blue-800 rounded text-xs font-medium">{r.allele2}</span>
                      {r.confidence2 != null && <span className="text-xs text-gray-400 ml-1">(p={r.confidence2.toFixed(2)})</span>}
                    </div>
                  ))}
                </div>
                {sample.hla_alignment?.length > 0 && (
                  <div className="mt-2 flex flex-wrap gap-2">
                    {sample.hla_alignment.map((a, i) => (
                      <div key={i} className="bg-white px-3 py-1.5 rounded shadow-sm text-xs text-gray-600">
                        <span className="font-medium">{a.file.includes('ClassI') ? 'Class I' : a.file.includes('ClassII') ? 'Class II' : 'Alignment'}:</span>{' '}
                        {a.reads_processed?.toLocaleString()} reads, {a.alignment_rate}% aligned ({a.reads_aligned?.toLocaleString()} reads)
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
            {/* Whatshap for single samples (germline phasing) */}
            {sample.whatshap?.stats?.length > 0 && (() => {
              const allSummary = sample.whatshap.stats.find(s => s.summary?.chromosome === 'ALL');
              if (!allSummary) return null;
              const s = allSummary.summary;
              return (
                <div className="mt-3">
                  <div className="text-xs font-medium text-gray-500 mb-1.5">Germline Phasing (WhatsHap)</div>
                  <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                    {['variants', 'phased', 'blocks'].map(key => s[key] !== undefined && (
                      <div key={key} className="bg-white px-3 py-2 rounded shadow-sm">
                        <div className="text-xs text-gray-500">{key}</div>
                        <div className="font-semibold text-gray-800 text-sm">{formatQcValue(s[key])}</div>
                      </div>
                    ))}
                  </div>
                </div>
              );
            })()}
          </div>
        );
      };

      const renderMultiSampleCard = (ms) => {
        const categories = {};
        (ms.metrics || []).forEach(m => {
          if (!categories[m.category]) categories[m.category] = [];
          categories[m.category].push(m);
        });

        return (
          <div key={ms.run_dir} className="border border-purple-200 bg-purple-50 rounded-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h4 className="font-semibold text-gray-800 flex items-center gap-2">
                <Icon name="layers" size={16} className="text-purple-600" />
                {ms.label}
              </h4>
              <span className="text-xs text-gray-500">{ms.run_ids}</span>
            </div>

            {Object.keys(categories).length > 0 && Object.entries(categories).map(([cat, metrics]) => (
              <div key={cat} className="mb-3">
                <div className="text-xs font-medium text-gray-500 mb-1.5">{cat}</div>
                <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                  {metrics.map((m, i) => (
                    <div key={i} className="bg-white px-3 py-2 rounded shadow-sm">
                      <div className="text-xs text-gray-500">{m.label}</div>
                      <div className="font-semibold text-gray-800 text-sm">{formatSummaryValue(m.value, m.format)}</div>
                    </div>
                  ))}
                </div>
              </div>
            ))}

            {/* Somalier */}
            {ms.somalier?.pairs?.length > 0 && (
              <div className="mb-3">
                <div className="text-xs font-medium text-gray-500 mb-1.5">Sample Validation (Somalier)</div>
                <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                  {ms.somalier.pairs.map((p, i) => (
                    <div key={i} className="bg-white px-3 py-2 rounded shadow-sm text-sm">
                      <div className="text-xs text-gray-500">
                        {p.sample_a?.split('-').pop()} vs {p.sample_b?.split('-').pop()}
                      </div>
                      <span className={`font-semibold ${p.relatedness >= 0.9 ? 'text-green-700' : p.relatedness >= 0.5 ? 'text-yellow-700' : 'text-red-700'}`}>
                        {formatQcValue(p.relatedness)}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Whatshap summary */}
            {ms.whatshap?.stats?.length > 0 && (() => {
              const allSummary = ms.whatshap.stats.find(s => s.summary?.chromosome === 'ALL');
              if (!allSummary) return null;
              const s = allSummary.summary;
              return (
                <div className="mb-3">
                  <div className="text-xs font-medium text-gray-500 mb-1.5">Phasing (WhatsHap)</div>
                  <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                    {['variants', 'phased', 'blocks'].map(key => s[key] !== undefined && (
                      <div key={key} className="bg-white px-3 py-2 rounded shadow-sm">
                        <div className="text-xs text-gray-500">{key}</div>
                        <div className="font-semibold text-gray-800 text-sm">{formatQcValue(s[key])}</div>
                      </div>
                    ))}
                  </div>
                </div>
              );
            })()}

            {/* LOHHLA */}
            {ms.parse_lohhla?.length > 0 && (
              <div className="mb-3">
                <div className="text-xs font-medium text-gray-500 mb-1.5">HLA Loss (LOHHLA)</div>
                <div className="flex flex-wrap gap-2">
                  {ms.parse_lohhla.map((r, i) => (
                    <div key={i} className="flex items-center gap-2 bg-white px-3 py-1.5 rounded shadow-sm">
                      <span className="font-medium text-sm">{r.allele}</span>
                      <span className={`text-xs px-2 py-0.5 rounded ${r.lohhla_allele_loss_pval < 0.05 ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'}`}>
                        p = {formatQcValue(r.lohhla_allele_loss_pval)}
                      </span>
                      {r.lohhla_allele_loss_pval < 0.05 && (
                        <span className="text-xs text-red-600 font-medium">LOH</span>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}

            {ms.lohhla?.predictions?.length > 0 && !ms.parse_lohhla?.length && (
              <div className="mb-3">
                <div className="text-xs font-medium text-gray-500 mb-1.5">HLA Loss Predictions</div>
                <div className="overflow-x-auto">
                  <table className="w-full text-xs border-collapse">
                    <thead>
                      <tr className="bg-white">
                        {['HLA Type 1', 'HLA Type 2', 'Copy# T1', 'Copy# T2', 'P-Value', 'Loss', 'Kept'].map(col => (
                          <th key={col} className="py-1 px-2 text-left font-medium border-b">{col}</th>
                        ))}
                      </tr>
                    </thead>
                    <tbody>
                      {ms.lohhla.predictions.map((r, i) => (
                        <tr key={i} className="border-b">
                          <td className="py-1 px-2">{r.HLA_A_type1}</td>
                          <td className="py-1 px-2">{r.HLA_A_type2}</td>
                          <td className="py-1 px-2">{formatQcValue(r.HLA_type1copyNum_withBAF)}</td>
                          <td className="py-1 px-2">{formatQcValue(r.HLA_type2copyNum_withBAF)}</td>
                          <td className="py-1 px-2">
                            <span className={`px-1 py-0.5 rounded text-xs ${r.PVal_unique < 0.05 ? 'bg-red-100 text-red-800' : ''}`}>
                              {formatQcValue(r.PVal_unique)}
                            </span>
                          </td>
                          <td className="py-1 px-2 text-red-700">{r.LossAllele}</td>
                          <td className="py-1 px-2 text-green-700">{r.KeptAllele}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            )}
          </div>
        );
      };

      // Render files section
      const renderFilesSection = () => {
        const { funnel_plots, cnvkit, igv_reports, other_pdfs } = files;
        const hasFiles = funnel_plots?.length || cnvkit?.length || igv_reports?.length || other_pdfs?.length;
        if (!hasFiles) return null;

        return (
          <div className="bg-white rounded-lg shadow-md p-6">
            <h3 className="text-lg font-semibold text-gray-800 mb-4 flex items-center gap-2">
              <Icon name="file" size={20} />
              Reports & Figures
            </h3>

            {funnel_plots.length > 0 && (
              <div className="mb-4">
                <h4 className="text-sm font-medium text-gray-700 mb-2">Funnel Plots</h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  {funnel_plots.map((f, i) => (
                    <div key={i}>
                      <div className="text-xs text-gray-500 mb-1">{f.tool.replace('lenstools_', '').replace('_funnel', '')} - {f.run_dir}</div>
                      <iframe
                        src={`${API_BASE}/api/qc-file?path=${encodeURIComponent(f.path)}`}
                        className="w-full border border-gray-200 rounded"
                        style={{ height: '400px' }}
                        title={f.name}
                      />
                    </div>
                  ))}
                </div>
              </div>
            )}

            {cnvkit.length > 0 && (
              <div className="mb-4">
                <h4 className="text-sm font-medium text-gray-700 mb-2">CNVkit</h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  {cnvkit.map((f, i) => (
                    <div key={i}>
                      <div className="text-xs text-gray-500 mb-1">{f.tool.replace('cnvkit_', '')} - {f.run_dir}</div>
                      <iframe
                        src={`${API_BASE}/api/qc-file?path=${encodeURIComponent(f.path)}`}
                        className="w-full border border-gray-200 rounded"
                        style={{ height: '400px' }}
                        title={f.name}
                      />
                    </div>
                  ))}
                </div>
              </div>
            )}

            {igv_reports.length > 0 && (
              <div className="mb-4">
                <h4 className="text-sm font-medium text-gray-700 mb-2">IGV Reports</h4>
                {igv_reports.map((f, i) => (
                  <a key={i}
                    href={`${API_BASE}/api/qc-file?path=${encodeURIComponent(f.path)}`}
                    target="_blank" rel="noopener noreferrer"
                    className="inline-flex items-center gap-2 text-sm text-indigo-600 hover:text-indigo-800 underline mr-4"
                  >
                    <Icon name="external-link" size={14} />
                    {f.name} ({f.run_dir})
                  </a>
                ))}
              </div>
            )}

            {other_pdfs.length > 0 && (
              <div className="mb-4">
                <h4 className="text-sm font-medium text-gray-700 mb-2">Other PDFs</h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  {other_pdfs.map((f, i) => (
                    <div key={i}>
                      <div className="text-xs text-gray-500 mb-1">{f.tool} - {f.run_dir}</div>
                      <iframe
                        src={`${API_BASE}/api/qc-file?path=${encodeURIComponent(f.path)}`}
                        className="w-full border border-gray-200 rounded"
                        style={{ height: '400px' }}
                        title={f.name}
                      />
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        );
      };

      // Render grouped or ungrouped view
      const renderContent = () => {
        if (hasGroups) {
          const sharedSamples = samples.filter(s => !s.group);
          return (
            <React.Fragment>
              {groups.map(group => {
                const groupSamples = samples.filter(s => s.group === group.id);
                const groupMulti = multi_sample.filter(ms => ms.group === group.id);
                return (
                  <div key={group.id} className="mb-6">
                    <div className="flex items-center gap-2 mb-3 pb-2 border-b border-purple-200">
                      <Icon name="folder" size={18} className="text-purple-600" />
                      <span className="font-semibold text-purple-800">{group.label}</span>
                    </div>
                    <div className="space-y-3">
                      {groupSamples.map(renderSampleCard)}
                      {groupMulti.map(renderMultiSampleCard)}
                    </div>
                  </div>
                );
              })}
              {sharedSamples.length > 0 && (
                <div className="mb-6">
                  <div className="flex items-center gap-2 mb-3 pb-2 border-b border-gray-300">
                    <Icon name="layers" size={18} className="text-gray-600" />
                    <span className="font-semibold text-gray-700">Shared Among Groups</span>
                  </div>
                  <div className="space-y-3">
                    {sharedSamples.map(renderSampleCard)}
                  </div>
                </div>
              )}
            </React.Fragment>
          );
        }
        return (
          <div className="space-y-3">
            {samples.map(renderSampleCard)}
            {multi_sample.map(renderMultiSampleCard)}
          </div>
        );
      };

      return (
        <div className="space-y-4">
          {/* Warning banner for inferred groups */}
          {groups_source === 'inferred' && (
            <div className="bg-amber-50 border border-amber-200 rounded-lg px-4 py-3 flex items-center gap-2">
              <Icon name="alert-triangle" size={18} className="text-amber-600 flex-shrink-0" />
              <span className="text-sm text-amber-800">
                Groups were auto-detected from file names. Load a manifest for definitive grouping.
              </span>
            </div>
          )}
          <div className="bg-white rounded-lg shadow-md p-6">
            <h2 className="text-xl font-semibold text-gray-800 mb-4 flex items-center gap-2">
              <Icon name="clipboard-check" size={24} />
              Quality Control: {patient}
            </h2>
            {renderContent()}
          </div>

          {renderFilesSection()}

          {/* In-Depth Tool Outputs */}
          {patientData && (
            <div className="bg-white rounded-lg shadow-md">
              <button
                onClick={() => setShowInDepth(!showInDepth)}
                className="w-full p-4 flex items-center justify-between text-left hover:bg-gray-50 transition rounded-lg"
              >
                <span className="font-semibold text-gray-700 flex items-center gap-2">
                  <Icon name="code" size={18} />
                  In-Depth Tool Outputs
                </span>
                <Icon name={showInDepth ? 'chevron-up' : 'chevron-down'} size={20} className="text-gray-500" />
              </button>
              {showInDepth && (
                <div className="p-4 pt-0 border-t border-gray-200">
                  <PatientQCView patient={patient} qcData={qcData} />
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // Patient QC View Component (raw tool-level display, used in In-Depth section)
    const PatientQCView = ({ patient, qcData }) => {
      const patientData = qcData?.patients?.[patient];

      if (!patientData || Object.keys(patientData).length === 0) {
        return (
          <div className="bg-white rounded-lg shadow-md p-8 text-center">
            <Icon name="clipboard-check" size={48} color="#6b7280" className="mx-auto mb-4" />
            <h2 className="text-xl font-semibold text-gray-800 mb-2">No QC Data for {patient}</h2>
            <p className="text-gray-600">
              Quality control metrics are not available for this patient.
              <br />
              Check that QC files exist in <code className="bg-gray-100 px-1 rounded">outputs/qc/*/</code>
            </p>
          </div>
        );
      }

      // Organize run directories by type: single-sample vs multi-sample
      const runDirs = Object.keys(patientData).sort((a, b) => {
        // Sort single-sample first, then multi-sample
        const aMulti = a.includes('+');
        const bMulti = b.includes('+');
        if (aMulti !== bMulti) return aMulti ? 1 : -1;
        return a.localeCompare(b);
      });

      return (
        <div className="space-y-4">
          <div>
            <p className="text-sm text-gray-500 mb-4">
              {runDirs.length} sample group{runDirs.length !== 1 ? 's' : ''} with QC data
            </p>

            {runDirs.map(runDir => {
              const tools = patientData[runDir];
              const toolNames = Object.keys(tools).sort();
              const isMultiSample = runDir.includes('+');
              const prefixMap = { ad: 'Tumor DNA', ar: 'Tumor RNA', nd: 'Normal DNA', nr: 'Control RNA' };
              const humanLabel = runDir.split('+').map(part => {
                const prefix = part.split('-')[0];
                return prefixMap[prefix] || part;
              }).join(' + ');

              return (
                <div key={runDir} className="mb-6">
                  <div className="flex items-center gap-2 mb-3 pb-2 border-b border-gray-200">
                    <Icon name={isMultiSample ? 'layers' : 'file'} size={16} className="text-gray-600" />
                    <span className="font-medium text-gray-800">{humanLabel}</span>
                    <span className="text-xs text-gray-400">{runDir}</span>
                    <span className="text-xs text-gray-500 ml-auto">{toolNames.length} tools</span>
                  </div>
                  <div className="space-y-2 ml-2">
                    {toolNames.map(toolName => (
                      <QCToolSection
                        key={toolName}
                        toolName={toolName}
                        toolData={tools[toolName]}
                        patientId={patient}
                      />
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      );
    };

    // Joint Analysis Panel Component (for multi-group patients)
    const JointAnalysisPanel = ({ patient, qcData }) => {
      const [activeSection, setActiveSection] = useState('sharedness');

      if (!patient || !patient.isMultiGroup || patient.groups.length < 2) {
        return (
          <div className="bg-white rounded-lg shadow-md p-8 text-center">
            <Icon name="git-compare" size={48} color="#6b7280" className="mx-auto mb-4" />
            <h2 className="text-xl font-semibold text-gray-800 mb-2">Joint Analysis Not Available</h2>
            <p className="text-gray-600">
              Joint analysis requires a patient with multiple groups/timepoints.
            </p>
          </div>
        );
      }

      const groups = patient.groups;

      return (
        <div className="space-y-6">
          <div className="bg-white rounded-lg shadow-md p-6">
            <h2 className="text-xl font-semibold text-gray-800 mb-2 flex items-center gap-2">
              <Icon name="git-compare" size={24} />
              Joint Analysis: {patient.id}
            </h2>
            <p className="text-sm text-gray-600 mb-4">
              Comparing {groups.length} groups: {groups.join(' vs ')}
            </p>

            {/* Section tabs */}
            <div className="flex flex-wrap gap-2 border-b border-gray-200 pb-4 mb-6">
              {[
                { id: 'sharedness', label: 'pMHC Sharedness', icon: 'layers' },
                { id: 'expression', label: 'Expression Changes', icon: 'trending-up' },
                { id: 'gainloss', label: 'Gained/Lost Antigens', icon: 'plus-minus' },
                { id: 'allelic', label: 'Allelic Consistency', icon: 'shield-check' }
              ].map(section => (
                <button
                  key={section.id}
                  onClick={() => setActiveSection(section.id)}
                  className={`px-4 py-2 rounded-lg text-sm font-medium transition flex items-center gap-2 ${
                    activeSection === section.id
                      ? 'bg-purple-600 text-white'
                      : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                  }`}
                >
                  <Icon name={section.icon} size={16} />
                  {section.label}
                </button>
              ))}
            </div>

            {/* Section content */}
            {activeSection === 'sharedness' && <VennDiagramSection patient={patient} />}
            {activeSection === 'expression' && <ExpressionComparisonSection patient={patient} />}
            {activeSection === 'gainloss' && <GainedLostSection patient={patient} />}
            {activeSection === 'allelic' && <AllelicConsistencySection patient={patient} />}
          </div>
        </div>
      );
    };

    // Venn Diagram Section - pMHC Sharedness
    const VennDiagramSection = ({ patient }) => {
      const groups = patient.groups;

      const analysis = useMemo(() => {
        // Build peptide-allele sets for each group
        const peptideSets = {};
        groups.forEach(group => {
          peptideSets[group] = new Set(
            (patient.groupData[group]?.data || []).map(row => `${row.peptide}|${row.allele}`)
          );
        });

        // For 2 groups, compute intersection and exclusive sets
        if (groups.length === 2) {
          const [g1, g2] = groups;
          const set1 = peptideSets[g1];
          const set2 = peptideSets[g2];

          const shared = new Set([...set1].filter(x => set2.has(x)));
          const exclusive1 = new Set([...set1].filter(x => !set2.has(x)));
          const exclusive2 = new Set([...set2].filter(x => !set1.has(x)));

          return { peptideSets, shared, exclusive: { [g1]: exclusive1, [g2]: exclusive2 } };
        }

        // For >2 groups, compute all shared (intersection of all)
        const allSets = Object.values(peptideSets);
        const shared = new Set([...allSets[0]].filter(x => allSets.every(s => s.has(x))));
        const exclusive = {};
        groups.forEach(group => {
          exclusive[group] = new Set([...peptideSets[group]].filter(x => !shared.has(x)));
        });

        return { peptideSets, shared, exclusive };
      }, [patient, groups]);

      return (
        <div>
          <h3 className="text-lg font-semibold text-gray-800 mb-4">pMHC Sharedness Across Groups</h3>

          {/* Summary stats */}
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div className="bg-purple-50 border border-purple-200 rounded-lg p-4 text-center">
              <div className="text-3xl font-bold text-purple-700">{analysis.shared.size}</div>
              <div className="text-sm text-purple-600">Shared pMHCs</div>
              <div className="text-xs text-purple-500 mt-1">Present in all groups</div>
            </div>
            {groups.map(group => (
              <div key={group} className="bg-gray-50 border border-gray-200 rounded-lg p-4 text-center">
                <div className="text-3xl font-bold text-gray-700">{analysis.exclusive[group].size}</div>
                <div className="text-sm text-gray-600">Exclusive to {group}</div>
                <div className="text-xs text-gray-500 mt-1">Total: {analysis.peptideSets[group].size}</div>
              </div>
            ))}
          </div>

          {/* Simple Venn-like visualization for 2 groups */}
          {groups.length === 2 && (
            <div className="flex justify-center items-center gap-0 my-8">
              <div className="w-40 h-40 rounded-full bg-blue-100 border-2 border-blue-400 flex items-center justify-center -mr-12 z-10">
                <div className="text-center -ml-8">
                  <div className="text-2xl font-bold text-blue-700">{analysis.exclusive[groups[0]].size}</div>
                  <div className="text-xs text-blue-600">{groups[0]} only</div>
                </div>
              </div>
              <div className="w-24 h-40 flex items-center justify-center z-20">
                <div className="text-center bg-purple-200 px-4 py-2 rounded-lg">
                  <div className="text-2xl font-bold text-purple-700">{analysis.shared.size}</div>
                  <div className="text-xs text-purple-600">Shared</div>
                </div>
              </div>
              <div className="w-40 h-40 rounded-full bg-green-100 border-2 border-green-400 flex items-center justify-center -ml-12 z-10">
                <div className="text-center -mr-8">
                  <div className="text-2xl font-bold text-green-700">{analysis.exclusive[groups[1]].size}</div>
                  <div className="text-xs text-green-600">{groups[1]} only</div>
                </div>
              </div>
            </div>
          )}

          {/* Detailed table */}
          <div className="bg-gray-50 rounded-lg p-4 max-h-64 overflow-y-auto">
            <h4 className="text-sm font-semibold text-gray-700 mb-2">Shared pMHCs ({analysis.shared.size})</h4>
            {analysis.shared.size > 0 ? (
              <div className="flex flex-wrap gap-2">
                {[...analysis.shared].slice(0, 50).map(key => {
                  const [peptide, allele] = key.split('|');
                  return (
                    <span key={key} className="px-2 py-1 bg-purple-100 text-purple-800 rounded text-xs font-mono">
                      {peptide} ({allele})
                    </span>
                  );
                })}
                {analysis.shared.size > 50 && (
                  <span className="px-2 py-1 bg-gray-200 text-gray-600 rounded text-xs">
                    +{analysis.shared.size - 50} more
                  </span>
                )}
              </div>
            ) : (
              <p className="text-sm text-gray-500">No shared pMHCs between groups.</p>
            )}
          </div>
        </div>
      );
    };

    // Expression Comparison Section
    const ExpressionComparisonSection = ({ patient }) => {
      const groups = patient.groups;

      const comparison = useMemo(() => {
        if (groups.length < 2) return { data: [], hasExpression: false };

        const [g1, g2] = groups;
        const data1 = patient.groupData[g1]?.data || [];
        const data2 = patient.groupData[g2]?.data || [];

        // Index data2 by peptide-allele
        const index2 = new Map();
        data2.forEach(row => index2.set(`${row.peptide}|${row.allele}`, row));

        // Find matching peptides and compute fold changes
        const compared = [];
        data1.forEach(row1 => {
          const key = `${row1.peptide}|${row1.allele}`;
          const row2 = index2.get(key);
          if (row2) {
            const tpm1 = parseFloat(row1.tpm) || 0;
            const tpm2 = parseFloat(row2.tpm) || 0;
            const log2fc = (tpm1 > 0 && tpm2 > 0) ? Math.log2(tpm2 / tpm1) : 0;
            compared.push({
              peptide: row1.peptide,
              allele: row1.allele,
              tpm1, tpm2, log2fc,
              vaf1: parseFloat(row1.vaf) || 0,
              vaf2: parseFloat(row2.vaf) || 0
            });
          }
        });

        // Sort by absolute fold change
        compared.sort((a, b) => Math.abs(b.log2fc) - Math.abs(a.log2fc));

        const hasExpression = compared.some(c => c.tpm1 > 0 || c.tpm2 > 0);
        return { data: compared, hasExpression, g1, g2 };
      }, [patient, groups]);

      if (!comparison.hasExpression) {
        return (
          <div className="text-center py-8">
            <Icon name="bar-chart-2" size={48} color="#9ca3af" className="mx-auto mb-4" />
            <p className="text-gray-500">No expression data available for comparison.</p>
          </div>
        );
      }

      return (
        <div>
          <h3 className="text-lg font-semibold text-gray-800 mb-4">Expression Changes ({comparison.g1}  {comparison.g2})</h3>

          {/* Summary */}
          <div className="grid grid-cols-3 gap-4 mb-6">
            <div className="bg-red-50 border border-red-200 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-red-700">
                {comparison.data.filter(d => d.log2fc < -1).length}
              </div>
              <div className="text-sm text-red-600">Downregulated</div>
              <div className="text-xs text-red-500">(log2FC &lt; -1)</div>
            </div>
            <div className="bg-gray-50 border border-gray-200 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-gray-700">
                {comparison.data.filter(d => d.log2fc >= -1 && d.log2fc <= 1).length}
              </div>
              <div className="text-sm text-gray-600">Stable</div>
              <div className="text-xs text-gray-500">(|log2FC|  1)</div>
            </div>
            <div className="bg-green-50 border border-green-200 rounded-lg p-4 text-center">
              <div className="text-2xl font-bold text-green-700">
                {comparison.data.filter(d => d.log2fc > 1).length}
              </div>
              <div className="text-sm text-green-600">Upregulated</div>
              <div className="text-xs text-green-500">(log2FC &gt; 1)</div>
            </div>
          </div>

          {/* Top changes table */}
          <div className="bg-gray-50 rounded-lg p-4 max-h-80 overflow-y-auto">
            <h4 className="text-sm font-semibold text-gray-700 mb-3">Top Expression Changes</h4>
            <table className="w-full text-sm">
              <thead>
                <tr className="border-b border-gray-300">
                  <th className="text-left py-2">Peptide</th>
                  <th className="text-left py-2">Allele</th>
                  <th className="text-right py-2">{comparison.g1} TPM</th>
                  <th className="text-right py-2">{comparison.g2} TPM</th>
                  <th className="text-right py-2">Log2 FC</th>
                </tr>
              </thead>
              <tbody>
                {comparison.data.slice(0, 20).map((row, idx) => (
                  <tr key={idx} className="border-b border-gray-200">
                    <td className="py-2 font-mono text-xs">{row.peptide}</td>
                    <td className="py-2 font-mono text-xs">{row.allele}</td>
                    <td className="py-2 text-right">{row.tpm1.toFixed(2)}</td>
                    <td className="py-2 text-right">{row.tpm2.toFixed(2)}</td>
                    <td className={`py-2 text-right font-semibold ${row.log2fc > 1 ? 'text-green-600' : row.log2fc < -1 ? 'text-red-600' : 'text-gray-600'}`}>
                      {row.log2fc.toFixed(2)}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      );
    };

    // Gained/Lost Antigens Section
    const GainedLostSection = ({ patient }) => {
      const groups = patient.groups;

      const analysis = useMemo(() => {
        if (groups.length < 2) return { gained: [], lost: [], retained: [] };

        const [g1, g2] = groups;
        const peptides1 = new Set((patient.groupData[g1]?.data || []).map(r => r.peptide));
        const peptides2 = new Set((patient.groupData[g2]?.data || []).map(r => r.peptide));

        const gained = [...peptides2].filter(p => !peptides1.has(p));
        const lost = [...peptides1].filter(p => !peptides2.has(p));
        const retained = [...peptides1].filter(p => peptides2.has(p));

        return { gained, lost, retained, g1, g2 };
      }, [patient, groups]);

      return (
        <div>
          <h3 className="text-lg font-semibold text-gray-800 mb-4">Antigen Changes ({analysis.g1}  {analysis.g2})</h3>

          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            {/* Lost */}
            <div className="bg-red-50 border border-red-200 rounded-lg p-4">
              <div className="flex items-center gap-2 mb-3">
                <Icon name="minus-circle" size={20} className="text-red-600" />
                <span className="font-semibold text-red-800">Lost Antigens</span>
                <span className="ml-auto text-2xl font-bold text-red-700">{analysis.lost.length}</span>
              </div>
              <div className="max-h-40 overflow-y-auto">
                {analysis.lost.length > 0 ? (
                  <div className="flex flex-wrap gap-1">
                    {analysis.lost.slice(0, 30).map(p => (
                      <span key={p} className="px-2 py-0.5 bg-red-100 text-red-700 rounded text-xs font-mono">{p}</span>
                    ))}
                    {analysis.lost.length > 30 && <span className="text-xs text-red-500">+{analysis.lost.length - 30} more</span>}
                  </div>
                ) : (
                  <p className="text-sm text-red-400">No antigens lost</p>
                )}
              </div>
            </div>

            {/* Retained */}
            <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
              <div className="flex items-center gap-2 mb-3">
                <Icon name="check-circle" size={20} className="text-gray-600" />
                <span className="font-semibold text-gray-800">Retained</span>
                <span className="ml-auto text-2xl font-bold text-gray-700">{analysis.retained.length}</span>
              </div>
              <p className="text-sm text-gray-500">Present in both groups</p>
            </div>

            {/* Gained */}
            <div className="bg-green-50 border border-green-200 rounded-lg p-4">
              <div className="flex items-center gap-2 mb-3">
                <Icon name="plus-circle" size={20} className="text-green-600" />
                <span className="font-semibold text-green-800">Gained Antigens</span>
                <span className="ml-auto text-2xl font-bold text-green-700">{analysis.gained.length}</span>
              </div>
              <div className="max-h-40 overflow-y-auto">
                {analysis.gained.length > 0 ? (
                  <div className="flex flex-wrap gap-1">
                    {analysis.gained.slice(0, 30).map(p => (
                      <span key={p} className="px-2 py-0.5 bg-green-100 text-green-700 rounded text-xs font-mono">{p}</span>
                    ))}
                    {analysis.gained.length > 30 && <span className="text-xs text-green-500">+{analysis.gained.length - 30} more</span>}
                  </div>
                ) : (
                  <p className="text-sm text-green-400">No new antigens gained</p>
                )}
              </div>
            </div>
          </div>
        </div>
      );
    };

    // Allelic Consistency Section (LOH Detection)
    const AllelicConsistencySection = ({ patient }) => {
      const groups = patient.groups;

      const analysis = useMemo(() => {
        // Collect alleles from each group
        const allelesByGroup = {};
        groups.forEach(group => {
          allelesByGroup[group] = patient.groupData[group]?.alleles || new Set();
        });

        // Find all unique alleles
        const allAlleles = new Set();
        Object.values(allelesByGroup).forEach(set => {
          set.forEach(a => allAlleles.add(a));
        });

        // Categorize alleles
        const consistent = [];
        const potentialLOH = [];

        allAlleles.forEach(allele => {
          const presentIn = groups.filter(g => allelesByGroup[g].has(allele));
          if (presentIn.length === groups.length) {
            consistent.push({ allele, status: 'present' });
          } else {
            potentialLOH.push({
              allele,
              presentIn,
              absentIn: groups.filter(g => !allelesByGroup[g].has(allele))
            });
          }
        });

        return { consistent, potentialLOH, allelesByGroup, groups };
      }, [patient, groups]);

      return (
        <div>
          <h3 className="text-lg font-semibold text-gray-800 mb-4">Allelic Consistency Check</h3>

          {/* Alert for potential LOH */}
          {analysis.potentialLOH.length > 0 ? (
            <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-6">
              <div className="flex items-center gap-2 mb-2">
                <Icon name="alert-triangle" size={20} className="text-yellow-600" />
                <h4 className="font-semibold text-yellow-800">Potential Loss of Heterozygosity Detected</h4>
              </div>
              <p className="text-sm text-yellow-700 mb-3">
                The following HLA alleles show inconsistent presence across groups, which may indicate LOH:
              </p>
              <div className="space-y-2">
                {analysis.potentialLOH.map(({ allele, presentIn, absentIn }) => (
                  <div key={allele} className="flex items-center gap-2 text-sm">
                    <span className="font-mono font-semibold text-yellow-900">{allele}</span>
                    <span className="text-yellow-700">
                      Present in: {presentIn.join(', ')} | Absent in: {absentIn.join(', ')}
                    </span>
                  </div>
                ))}
              </div>
            </div>
          ) : (
            <div className="bg-green-50 border-l-4 border-green-400 p-4 mb-6">
              <div className="flex items-center gap-2">
                <Icon name="check-circle" size={20} className="text-green-600" />
                <h4 className="font-semibold text-green-800">HLA Alleles Consistent Across Groups</h4>
              </div>
              <p className="text-sm text-green-700 mt-1">
                All {analysis.consistent.length} alleles are present in both groups. No evidence of LOH.
              </p>
            </div>
          )}

          {/* Allele comparison table */}
          <div className="bg-gray-50 rounded-lg p-4">
            <h4 className="text-sm font-semibold text-gray-700 mb-3">Allele Presence by Group</h4>
            <table className="w-full text-sm">
              <thead>
                <tr className="border-b border-gray-300">
                  <th className="text-left py-2">Allele</th>
                  {groups.map(g => (
                    <th key={g} className="text-center py-2">{g}</th>
                  ))}
                  <th className="text-left py-2">Status</th>
                </tr>
              </thead>
              <tbody>
                {[...analysis.consistent, ...analysis.potentialLOH].map(item => {
                  const allele = item.allele;
                  const isLOH = item.absentIn !== undefined;
                  return (
                    <tr key={allele} className={`border-b border-gray-200 ${isLOH ? 'bg-yellow-50' : ''}`}>
                      <td className="py-2 font-mono text-xs">{allele}</td>
                      {groups.map(g => (
                        <td key={g} className="py-2 text-center">
                          {analysis.allelesByGroup[g].has(allele) ? (
                            <Icon name="check" size={16} className="text-green-600 mx-auto" />
                          ) : (
                            <Icon name="x" size={16} className="text-red-600 mx-auto" />
                          )}
                        </td>
                      ))}
                      <td className="py-2">
                        {isLOH ? (
                          <span className="text-xs px-2 py-0.5 bg-yellow-200 text-yellow-800 rounded">Potential LOH</span>
                        ) : (
                          <span className="text-xs px-2 py-0.5 bg-green-200 text-green-800 rounded">Consistent</span>
                        )}
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      );
    };

    // pMHC Cards Component
    const PMHCCards = ({ data, sortMetric, comments, setComments, selectedRow, setSelectedRow, hasCustomFormula }) => (
      <div className="mt-4">
        <h3 className="text-base font-semibold text-gray-800 mb-4">Top {data.length} pMHCs</h3>
        <div className="grid gap-3">
          {data.map((row, idx) => (
            <PMHCCard key={`${row.peptide}-${row.allele}-${idx}`} row={row} idx={idx} sortMetric={sortMetric} comments={comments} setComments={setComments} isSelected={selectedRow?.peptide === row.peptide && selectedRow?.allele === row.allele} onSelect={() => setSelectedRow(row)} hasCustomFormula={hasCustomFormula} />
          ))}
        </div>
      </div>
    );

    // pMHC Card Component
    const PMHCCard = ({ row, idx, sortMetric, comments, setComments, isSelected, onSelect, hasCustomFormula }) => {
      const key = `${row.peptide}-${row.allele}`;
      const displayValue = (v) => { if (v === null || v === undefined || v === '' || v === 'NA') return 'N/A'; const num = parseFloat(v); return isNaN(num) ? 'N/A' : num.toFixed(3); };

      return (
        <div onClick={onSelect} className={`bg-white rounded-lg p-4 cursor-pointer transition shadow-sm hover:shadow-md ${isSelected ? 'border-2 border-indigo-500 bg-indigo-50' : 'border border-gray-200'}`}>
          <div className="flex justify-between items-start mb-3">
            <div>
              <div className="text-lg font-bold text-gray-800 mb-0.5 font-mono">{row.peptide}</div>
              <div className="text-sm text-gray-500 font-mono">{row.allele} &bull; {row.antigen_source}</div>
            </div>
            <div className="bg-indigo-600 text-white px-3 py-1 rounded-full text-sm font-bold">#{idx + 1}</div>
          </div>

          <div className={`grid gap-3 mb-3 p-3 bg-gray-50 rounded-md ${hasCustomFormula ? 'grid-cols-2 md:grid-cols-4 lg:grid-cols-7' : 'grid-cols-2 md:grid-cols-3 lg:grid-cols-6'}`}>
            {hasCustomFormula && (
              <div className="bg-indigo-100 rounded p-2 -m-1">
                <MetricDisplay label="Custom Score" value={row.custom_score} highlight />
              </div>
            )}
            <MetricDisplay label="Priority Score" value={row[sortMetric]} />
            <MetricDisplay label="MHCFlurry Binding Aff" value={row['mhcflurry_2.1.1.aff']} />
            <MetricDisplay label="MHCFlurry Pres Score" value={row['mhcflurry_2.1.1.pres_score']} />
            <MetricDisplay label="CCF" value={row.ccf} />
            <MetricDisplay label="VAF" value={row.vaf} />
            <MetricDisplay label="Log2(TPM)" value={row.tpm} transform={v => { const num = parseFloat(v); return (!isNaN(num) && num > 0) ? Math.log2(num) : null; }} />
          </div>

          <div>
            <label className="block mb-1 text-xs font-medium text-gray-700">Comments</label>
            <textarea
              value={comments[key] || ''} onChange={(e) => { e.stopPropagation(); setComments({ ...comments, [key]: e.target.value }); }} onClick={(e) => e.stopPropagation()}
              placeholder="Add your notes about this pMHC..."
              className="w-full min-h-14 px-3 py-2 text-sm border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-y"
            />
          </div>
        </div>
      );
    };

    // Metric Display Component
    const MetricDisplay = ({ label, value, highlight, transform }) => {
      const displayValue = (v) => {
        if (v === null || v === undefined || v === '' || v === 'NA') return 'N/A';
        const transformedValue = transform ? transform(v) : parseFloat(v);
        return (transformedValue === null || isNaN(transformedValue)) ? 'N/A' : transformedValue.toFixed(3);
      };
      return (
        <div>
          <div className={`text-xs mb-0.5 uppercase tracking-wide ${highlight ? 'text-indigo-700 font-semibold' : 'text-gray-500'}`}>{label}</div>
          <div className={`text-sm font-semibold ${highlight ? 'text-indigo-900' : 'text-gray-800'}`}>{displayValue(value)}</div>
        </div>
      );
    };

    // Render
    try {
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<LENSViewer />);
    } catch (error) {
      console.error('Failed to render LENS Viewer:', error);
      document.getElementById('root').innerHTML =
        '<div class="p-8 font-sans max-w-xl">' +
        '<h2 class="text-red-600 text-xl font-bold mb-4">Application Error</h2>' +
        '<p class="mb-2">Failed to initialize the LENS Viewer.</p>' +
        '<pre class="bg-gray-100 p-4 rounded text-xs overflow-auto">' + error.toString() + '</pre>' +
        '<p class="mt-4"><a href="javascript:location.reload()" class="text-blue-600 hover:underline">Click here to retry</a></p>' +
        '</div>';
    }
  </script>
</body>
</html>
