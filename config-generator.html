<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAFT Workflow Configuration Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .accordion-content.active {
            max-height: 5000px;
            transition: max-height 0.5s ease-in;
        }
        .methods-output-section {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .methods-output-section.active {
            max-height: 600px;
            transition: max-height 0.5s ease-in;
        }
        .config-output-section {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .config-output-section.active {
            max-height: 600px;
            transition: max-height 0.5s ease-in;
        }
        .tool-checkbox:checked ~ .tool-options {
            opacity: 1;
        }
        .tool-options {
            opacity: 0.4;
        }
        .secondary-tool {
            font-style: italic;
            opacity: 0.7;
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #1f2937;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .loading {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-6">
    <div class="max-w-7xl mx-auto">
        <header class="mb-6">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-900 mb-1">RAFT Workflow Configuration Generator</h1>
            <p class="text-sm text-gray-600">Generate Nextflow configuration files for RAFT workflows</p>
        </header>

        <!-- Workflow Selection -->
        <div class="bg-white rounded-lg shadow-md p-4 md:p-6 mb-4">
            <h2 class="text-base font-semibold mb-3">Workflow Selection</h2>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-3 mb-3">
                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Workflow Type</label>
                    <select id="workflowType" class="w-full border border-gray-300 rounded-md px-2 py-1.5 text-sm focus:ring-2 focus:ring-blue-500">
                        <option value="">Select workflow...</option>
                        <option value="lens">LENS - Landscape of Effective Neoantigens Software</option>
                    </select>
                </div>

                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Species</label>
                    <select id="species" class="w-full border border-gray-300 rounded-md px-2 py-1.5 text-sm focus:ring-2 focus:ring-blue-500">
                        <option value="">Select species...</option>
                        <option value="human">Human (Homo sapiens)</option>
                        <option value="mouse">Mouse (Mus musculus)</option>
                    </select>
                </div>

                <div>
                    <label class="block text-xs font-medium text-gray-700 mb-1">Starting Data</label>
                    <select id="startingData" class="w-full border border-gray-300 rounded-md px-2 py-1.5 text-sm focus:ring-2 focus:ring-blue-500">
                        <option value="">Select starting point...</option>
                        <option value="fastqs">FASTQs</option>
                        <option value="bams">BAMs</option>
                    </select>
                </div>
            </div>

            <div class="mb-3">
                <label class="block text-xs font-medium text-gray-700 mb-1">Workflow Version</label>
                <select id="workflowVersion" class="w-full border border-gray-300 rounded-md px-2 py-1.5 text-sm focus:ring-2 focus:ring-blue-500">
                    <option value="">Select version...</option>
                    <option value="lens-v1.8">lens-v1.8</option>
                    <option value="lens-v1.7">lens-v1.7</option>
                    <option value="lens-v1.6">lens-v1.6</option>
                </select>
            </div>

            <button id="loadWorkflow" class="bg-blue-600 text-white px-4 py-2 text-sm rounded-md hover:bg-blue-700 transition flex items-center gap-2">
                <span>Load Workflow Configuration</span>
                <div id="loadingSpinner" class="loading hidden"></div>
            </button>

            <div id="errorMessage" class="mt-3 p-3 bg-red-50 border border-red-200 rounded-md text-sm text-red-700 hidden"></div>
        </div>

        <!-- Workflow Configuration -->
        <div id="workflowConfig" class="hidden">
            <div class="bg-white rounded-lg shadow-md p-4 md:p-6 mb-4">
                <h2 class="text-base font-semibold mb-3">Workflow Configuration</h2>
                <div id="configSections" class="space-y-3"></div>
            </div>

            <!-- Methods Description Section -->
            <div class="bg-white rounded-lg shadow-md overflow-hidden mb-4">
                <div class="bg-gray-100 px-4 py-3 cursor-pointer flex justify-between items-center" id="methodsHeader">
                    <h2 class="text-base font-semibold">Methods Description</h2>
                    <svg class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>

                <div class="methods-output-section p-4">
                    <div class="mb-3 flex flex-wrap gap-2">
                        <button id="copyMethods" class="bg-green-600 text-white px-3 py-1.5 text-sm rounded-md hover:bg-green-700 transition">
                            Copy to Clipboard
                        </button>
                        <button id="downloadMethods" class="bg-blue-600 text-white px-3 py-1.5 text-sm rounded-md hover:bg-blue-700 transition">
                            Download Methods.txt
                        </button>
                    </div>

                    <textarea id="methodsOutput" class="w-full h-64 md:h-80 font-mono text-xs border border-gray-300 rounded-md p-3 focus:ring-2 focus:ring-blue-500" readonly></textarea>
                </div>
            </div>

            <!-- Output Section -->
            <div class="bg-white rounded-lg shadow-md overflow-hidden">
                <div class="bg-gray-100 px-4 py-3 cursor-pointer flex justify-between items-center" id="configHeader">
                    <h2 class="text-base font-semibold">Configuration File</h2>
                    <svg class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>

                <div class="config-output-section p-4">
                    <div class="mb-3 flex flex-wrap gap-2">
                        <button id="copyConfig" class="bg-green-600 text-white px-3 py-1.5 text-sm rounded-md hover:bg-green-700 transition">
                            Copy to Clipboard
                        </button>
                        <button id="downloadConfig" class="bg-blue-600 text-white px-3 py-1.5 text-sm rounded-md hover:bg-blue-700 transition">
                            Download .config
                        </button>
                        <button id="saveToRaft" class="bg-purple-600 text-white px-3 py-1.5 text-sm rounded-md hover:bg-purple-700 transition">
                            Save to RAFT
                        </button>
                    </div>

                    <textarea id="configOutput" class="w-full h-64 md:h-80 font-mono text-xs border border-gray-300 rounded-md p-3 focus:ring-2 focus:ring-blue-500" readonly></textarea>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Real LENS config data (from uploaded file)
        const LENS_CONFIG_TEXT = `params.dummy_file = "\${params.ref_dir}/dummy_file"

params.immuno$parse_immuno_manifest$molecule_filter = ''
params.immuno$parse_immuno_manifest$separator = '\\t'

# DNA Alignment
params.lens$alignment$manifest_to_dna_alns$fq_trim_tool = "fastp"
params.lens$alignment$manifest_to_dna_alns$fq_trim_tool_parameters = "[]"
params.lens$alignment$manifest_to_dna_alns$aln_tool = "bwa-mem2"
params.lens$alignment$manifest_to_dna_alns$aln_tool_parameters = "[]"
params.lens$alignment$manifest_to_dna_alns$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$alignment$manifest_to_dna_alns$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"

# DNA Alignment Processing
params.lens$alignment$alns_to_dna_procd_alns$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$alignment$alns_to_dna_procd_alns$bed = "\${params.ref_dir}/hg38_exome.bed"
params.lens$alignment$alns_to_dna_procd_alns$gtf = ""
params.lens$alignment$alns_to_dna_procd_alns$dup_marker_tool = "bamblaster"
params.lens$alignment$alns_to_dna_procd_alns$dup_marker_tool_parameters = "[]"
params.lens$alignment$alns_to_dna_procd_alns$base_recalibrator_tool = ""
params.lens$alignment$alns_to_dna_procd_alns$base_recalibrator_tool_parameters = "[]"
params.lens$alignment$alns_to_dna_procd_alns$indel_realign_tool = ""
params.lens$alignment$alns_to_dna_procd_alns$indel_realign_tool_parameters = "[]"
params.lens$alignment$alns_to_dna_procd_alns$known_sites_ref = "\${params.ref_dir}/Homo_sapiens_assembly38.dbsnp138.vcf.gz"

# RNA Alignment
params.lens$alignment$manifest_to_rna_alns$fq_trim_tool = "fastp"
params.lens$alignment$manifest_to_rna_alns$fq_trim_tool_parameters = "[]"
params.lens$alignment$manifest_to_rna_alns$aln_tool = "star"
params.lens$alignment$manifest_to_rna_alns$aln_tool_parameters = "['star': '--quantMode TranscriptomeSAM --twopassMode Basic --outSAMunmapped Within --outSAMtype BAM Unsorted']"
params.lens$alignment$manifest_to_rna_alns$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$alignment$manifest_to_rna_alns$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"

# RNA Alignment Processing
params.lens$alignment$alns_to_rna_procd_alns$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$alignment$alns_to_rna_procd_alns$bed = "\${params.ref_dir}/hg38_exome.bed"
params.lens$alignment$alns_to_rna_procd_alns$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$alignment$alns_to_rna_procd_alns$dup_marker_tool = ""
params.lens$alignment$alns_to_rna_procd_alns$dup_marker_tool_parameters = "[]"
params.lens$alignment$alns_to_rna_procd_alns$base_recalibrator_tool = ""
params.lens$alignment$alns_to_rna_procd_alns$base_recalibrator_tool_parameters = "[]"
params.lens$alignment$alns_to_rna_procd_alns$indel_realign_tool = ""
params.lens$alignment$alns_to_rna_procd_alns$indel_realign_tool_parameters = "[]"
params.lens$alignment$alns_to_rna_procd_alns$known_sites_ref = "\${params.ref_dir}/dummy_file"

# Transcript Quantification from RNA Alignments
params.lens$rna_quant$alns_to_transcript_counts$rna_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$rna_quant$alns_to_transcript_counts$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$rna_quant$alns_to_transcript_counts$tx_quant_tool = "salmon"
params.lens$rna_quant$alns_to_transcript_counts$tx_quant_tool_parameters = "[]"

# Somatic Variant Calling
params.lens$somatic$alns_to_som_vars$som_var_caller = "strelka2,mutect2"
params.lens$somatic$alns_to_som_vars$som_var_caller_parameters = "['gatk_filter_mutect_calls_suffix': '.gfilt']"
params.lens$somatic$alns_to_som_vars$som_var_caller_suffix = "['mutect2': '.mutect2', 'strelka2': '.strelka2', 'abra2': '.abra2']"
params.lens$somatic$alns_to_som_vars$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$somatic$alns_to_som_vars$bed = "\${params.ref_dir}/hg38_exome.bed"
params.lens$somatic$alns_to_som_vars$som_var_pon_vcf = "\${params.ref_dir}/1000g_pon.hg38.vcf.gz"
params.lens$somatic$alns_to_som_vars$som_var_af_vcf = "\${params.ref_dir}/af-only-gnomad.hg38.vcf.gz"
params.lens$somatic$alns_to_som_vars$known_sites_ref = "\${params.ref_dir}/small_exac_common_3.hg38.vcf.gz"
params.lens$somatic$alns_to_som_vars$species = "homo sapiens"

# Somatic Variant Filtering
params.lens$somatic$som_vars_to_filtd_som_vars$vcf_filtering_tool = 'bcftools'
params.lens$somatic$som_vars_to_filtd_som_vars$vcf_filtering_tool_parameters = "[]"

# Stringent Variant Filtering for MAF Generation
params.lens$somatic$som_vars_to_filtd_som_vars_hi_conf$vcf_filtering_tool = 'bcftools'
params.lens$somatic$som_vars_to_filtd_som_vars_hi_conf$vcf_filtering_tool_parameters = "['mutect2': '-i \\\\'FILTER=\\"PASS\\" && INFO/TLOD>6.3 && FORMAT/DP[0]>=10 && FORMAT/AD[0:1]>=3\\\\'', 'strelka2': '-i \\\\'FILTER=\\"PASS\\" && INFO/SomaticEVS > 12 && FORMAT/DP[0]>=8\\\\'']"

# SNV/InDel Filtering
params.lens$snpsift_filter_snvs$snpsift_snv_filter_parameters = "ANN[*].EFFECT has 'missense_variant'"
params.lens$snpsift_filter_indels$snpsift_indel_filter_parameters = "(ANN[*].EFFECT has 'conservative_inframe_insertion') || (ANN[*].EFFECT has 'conservative_inframe_deletion') || (ANN[*].EFFECT has 'disruptive_inframe_insertion') || (ANN[*].EFFECT has 'disruptive_inframe_deletion') || (ANN[*].EFFECT has 'frameshift_variant')"

# Somatic InDel Normalization
params.lens$somatic$som_vars_to_normd_som_vars$vcf_norming_tool = 'bcftools'
params.lens$somatic$som_vars_to_normd_som_vars$vcf_norming_tool_parameters = "[]"
params.lens$somatic$som_vars_to_normd_som_vars$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"

# Somatic Variant Merging
# Variant Merging and Phasing
params.lens$seq_variation$combine_strategy = "union"
# Intersection
params.lens$seq_variation$som_vars_to_isecd_som_vars$vcf_isecing_tool = "bedtools"
params.lens$seq_variation$som_vars_to_isecd_som_vars$vcf_isecing_tool_parameters = "[]"
# Union
params.lens$seq_variation$som_vars_to_union_som_vars$vcf_merging_tool = 'jacquard_merge'
params.lens$seq_variation$som_vars_to_union_som_vars$vcf_merging_tool_parameters = "['jacquard_merge': '--include_format_tags=\\"GT,AF,AU,CU,GU,TU,TAR,TIR,FREQ,VAF,DP,AD\\"']"

# Variant Annotation
params.lens$snpeff$annot_tool_ref = "\${params.ref_dir}/GRCh38.GENCODEv37"
params.lens$annotation$vcfs_to_vcf2maf$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$annotation$vcfs_to_vcf2maf$vcf2maf_parameters = '--ncbi-build GRCh38'

# Germline Variant Calling
params.lens$germline$alns_to_germ_vars$germ_var_caller = 'deepvariant'
params.lens$germline$alns_to_germ_vars$germ_var_caller_parameters = "['deepvariant': '--model_type WES']"
params.lens$germline$alns_to_germ_vars$germ_var_caller_suffix = "['deepvariant': '.deepv']"
params.lens$germline$alns_to_germ_vars$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$germline$alns_to_germ_vars$bed = "\${params.ref_dir}/hg38_exome.bed"

# Germline Variant Filtering
params.lens$germline$germ_vars_to_filtd_germ_vars$vcf_filtering_tool = 'bcftools'
params.lens$germline$germ_vars_to_filtd_germ_vars$vcf_filtering_tool_parameters = "[]"

# Misc Variant
params.lens$bcftools$bcftools_index$bcftools_index_parameters = ''
params.lens$bcftools$bcftools_index_somatic$bcftools_index_somatic_parameters = ''

# Somatic + Germline Merging
params.lens$seq_variation$germ_and_som_vars_to_tumor_vars$vcf_merge_tool = 'jacquard_merge'
params.lens$seq_variation$germ_and_som_vars_to_tumor_vars$vcf_merge_tool_parameters = "[]"

# Phasing of Somatic + Germline Variants
params.lens$seq_variation$make_phased_tumor_vars$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$seq_variation$make_phased_tumor_vars$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$seq_variation$make_phased_tumor_vars$species = 'human'
params.lens$seq_variation$make_phased_tumor_vars$var_phaser_tool = 'whatshap'
params.lens$seq_variation$make_phased_tumor_vars$var_phaser_tool_parameters = "['whatshap': '--ignore-read-groups']"

# Phasing of Germline Variants
params.lens$seq_variation$make_phased_germline_vars$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$seq_variation$make_phased_germline_vars$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$seq_variation$make_phased_germline_vars$var_phaser_tool = 'whatshap'
params.lens$seq_variation$make_phased_germline_vars$var_phaser_tool_parameters = "['whatshap': '--ignore-read-groups']"

# MHC Calling
params.lens$immuno$procd_fqs_to_rna_mhc_alleles$aln_tool = ""
params.lens$immuno$procd_fqs_to_rna_mhc_alleles$aln_tool_parameters = '--outSAMtype BAM SortedByCoordinate'
params.lens$immuno$procd_fqs_to_rna_mhc_alleles$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$immuno$procd_fqs_to_rna_mhc_alleles$mhc_caller_tool = 'seq2hla_ase,optitype_rna'
params.lens$immuno$procd_fqs_to_rna_mhc_alleles$mhc_caller_tool_parameters = "[]"
params.lens$immuno$procd_fqs_to_dna_mhc_alleles$aln_tool = ''
params.lens$immuno$procd_fqs_to_dna_mhc_alleles$aln_tool_parameters = "['razers3': '-i 90 -m 1 -dr 1']"
params.lens$immuno$procd_fqs_to_dna_mhc_alleles$aln_ref = ""
params.lens$immuno$procd_fqs_to_dna_mhc_alleles$mhc_caller_tool = 'optitype_dna'
params.lens$immuno$procd_fqs_to_dna_mhc_alleles$mhc_caller_tool_parameters = "[]"

# TCR Repertoire

# Splice Variants
params.lens$splice$alns_to_splice_variants$splice_var_caller = 'snaf'
params.lens$splice$alns_to_splice_variants$splice_var_caller_parameters = "[]"
params.lens$splice$alns_to_splice_variants$splice_var_caller_ref = "['snaf': \\"\${params.ref_dir}/snaf-data\\", 'netmhcpan': \\"\${params.ref_dir}/netMHCpan-4.1\\"]"
params.lens$splice$alns_to_splice_variants$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$splice$alns_to_splice_variants$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$splice$alns_to_splice_variants$gff = "\${params.ref_dir}/gencode.v37.annotation.gff3"
params.lens$splice$alns_to_splice_variants$species = "homo sapiens"

# Viral Detection
params.lens$viral$alns_to_viruses$viral_workflow = 'virdetect'
params.lens$viral$alns_to_viruses$viral_workflow_parameters = "[]"
params.lens$viral$alns_to_viruses$viral_ref = "\${params.ref_dir}/virus_masked_hg38.fa"
params.lens$viral$unaligned_fqs_to_virdetect_cds_counts$viral_cds_ref = "\${params.ref_dir}/virus.cds.2024f2.fa"

# Gene Fusion Calling
params.lens$fusion$procd_fqs_to_fusions$fusion_tool = 'starfusion'
params.lens$fusion$procd_fqs_to_fusions$fusion_tool_parameters = "['starfusion': '--examine_coding_effect']"
params.lens$fusion$procd_fqs_to_fusions$fusion_ref = "['starfusion': \\"\${params.ref_dir}/GRCh38_gencode_v37_CTAT_lib_Mar012021.plug-n-play\\"]"
params.lens$fusion$procd_fqs_to_fusions$dna_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$fusion$procd_fqs_to_fusions$gtf  = ""
params.lens$fusion$procd_fqs_to_fusions$species = 'Homo sapiens'

# Tumor Purity
params.lens$tumor_purity$alns_to_tumor_purities$tx_quant_tool = ''
params.lens$tumor_purity$alns_to_tumor_purities$tx_quant_tool_parameters = "[]"
params.lens$tumor_purity$alns_to_tumor_purities$tumor_purities_tool = 'sequenza'
params.lens$tumor_purity$alns_to_tumor_purities$tumor_purities_tool_parameters = "[sequenza_gc_wiggle: '-w 50', sequenza_bam2seqz: '', sequenza_seqz_binning: '-w 50']"
params.lens$tumor_purity$alns_to_tumor_purities$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$tumor_purity$alns_to_tumor_purities$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$tumor_purity$alns_to_tumor_purities$bed = "\${params.ref_dir}/hg38_exome.bed"

# CNA and cancer cell fraction
params.lens$copy_number_alterations$alns_to_cnas$cna_tool = 'cnvkit'
params.lens$copy_number_alterations$alns_to_cnas$cna_tool_refs = ''
params.lens$copy_number_alterations$alns_to_cnas$cna_tool_parameters = "[cnvkit_segment: '--drop-low-coverage', cnvkit_call: '--ploidy 2']"
params.lens$copy_number_alterations$alns_to_cnas$aln_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$copy_number_alterations$alns_to_cnas$bed = "\${params.ref_dir}/hg38_exome.bed"
params.lens$copy_number_alterations$alns_to_cnas$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"

# HLA Loss of heterozygosity
params.lens$hla_loh$alns_and_alleles_to_loh_hla$hla_loh_tool = 'lohhla'
params.lens$hla_loh$alns_and_alleles_to_loh_hla$hla_loh_tool_refs = "['lohhla': \\"\${params.ref_dir}/hla_fix.fasta\\"]"
params.lens$hla_loh$alns_and_alleles_to_loh_hla$hla_loh_tool_parameters = '[]'

# CTA/Self-antigens Neoantigen Workflow
params.lens$neos$selfs_to_neos$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$neos$selfs_to_neos$dna_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$neos$selfs_to_neos$cta_self_gene_list = "\${params.ref_dir}/cta.pirlygenes.25SEP2024.gene_list"
params.lens$neos$selfs_to_neos$samtools_index_parameters = ''
params.lens$neos$selfs_to_neos$lenstools_filter_expressed_self_parameters = '-p 50 --exclude-zeros'
params.lens$neos$selfs_to_neos$lenstools_get_expressed_self_bed_parameters = ''
params.lens$neos$selfs_to_neos$samtools_faidx_fetch_parameters = ''
params.lens$neos$selfs_to_neos$bcftools_index_parameters = ''

# ERVs Neoantigen Workflow
params.lens$neos$ervs_to_neos$dna_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$neos$ervs_to_neos$geve_general_ref = "\${params.ref_dir}/Hsap38.txt"
params.lens$neos$ervs_to_neos$lenstools_get_expressed_ervs_bed_parameters = ""
params.lens$neos$ervs_to_neos$lenstools_make_erv_peptides_parameters = ""
params.lens$neos$ervs_to_neos$lenstools_filter_expressed_ervs_parameters = ""
params.lens$neos$ervs_to_neos$lenstools_filter_ervs_by_rna_coverage_parameters = "--mean-depth 25"
params.lens$neos$ervs_to_neos$normal_control_quant = ""
params.lens$neos$ervs_to_neos$tpm_threshold = ""

# SNVs Neoantigen Workflow
params.lens$neos$snvs_to_neos$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$neos$snvs_to_neos$dna_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$neos$snvs_to_neos$pep_ref = "\${params.ref_dir}/gencode.v37.pc_translations.fa"
params.lens$neos$snvs_to_neos$som_var_type = "SNV"
params.lens$neos$snvs_to_neos$lenstools_filter_expressed_variants_parameters = "-p 50 --exclude-zeros"
params.lens$neos$snvs_to_neos$bcftools_index_phased_germline_parameters = ""
params.lens$neos$snvs_to_neos$bcftools_index_phased_tumor_parameters = ""
params.lens$neos$snvs_to_neos$lenstools_get_expressed_transcripts_bed_parameters = ""
params.lens$neos$snvs_to_neos$samtools_faidx_fetch_somatic_folder_parameters = ""

# InDels Neoantigen Workflow
params.lens$neos$indels_to_neos$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$neos$indels_to_neos$dna_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$neos$indels_to_neos$pep_ref = "\${params.ref_dir}/gencode.v37.pc_translations.fa"
params.lens$neos$indels_to_neos$som_var_type = "InDel"
params.lens$neos$indels_to_neos$lenstools_filter_expressed_variants_parameters = "-p 75"
params.lens$neos$indels_to_neos$bcftools_index_phased_germline_parameters = ""
params.lens$neos$indels_to_neos$bcftools_index_phased_tumor_parameters = ""
params.lens$neos$indels_to_neos$lenstools_get_expressed_transcripts_bed_parameters = ""
params.lens$neos$indels_to_neos$samtools_faidx_fetch_somatic_folder_parameters = ""

# Fusion Neoantigen Workflow
params.lens$neos$fusions_to_neos$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$neos$fusions_to_neos$dna_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$neos$fusions_to_neos$bedtools_index_phased_germline_parameters = ''
params.lens$neos$fusions_to_neos$lenstools_get_fusion_transcripts_bed_parameters = ''
params.lens$neos$fusions_to_neos$samtools_faidx_fetch_parameters = ''

# Viral Neoantigen Workflow
params.lens$neos$viruses_to_neos$viral_cds_ref = "\${params.ref_dir}/virus.cds.2024f2.fa"
params.lens$neos$viruses_to_neos$lenstools_filter_expressed_viruses_parameters = ""
params.lens$neos$viruses_to_neos$lenstools_filter_viruses_by_rna_coverage_parameters = "--coverage 1"
params.lens$neos$viruses_to_neos$lenstools_get_expressed_viral_bed_parameters = ""
params.lens$neos$viruses_to_neos$lenstools_make_viral_peptides_parameters = ""

# pMHC Summarization
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats$antigen_tool = 'mhcflurry'
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats$antigen_tool_parameters = '[]'
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats$antigen_tool_ref_dir = "['mhcflurry': \\"\${params.ref_dir}/mhcflurry\\"]"
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats$species = 'human'
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats$peptide_lengths = '8,9,10,11'

# pMHC Summarizatoin Second Pass
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats_second_pass$antigen_tool = ''
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats_second_pass$antigen_tool_parameters = '[]'     
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats_second_pass$antigen_tool_ref_dir = "[]"        
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats_second_pass$species = 'human'                  
params.lens$pmhc_characterization$peps_and_alleles_to_antigen_stats_second_pass$peptide_lengths = '8,9,10,11'

# Agretopicity Calculation
params.lens$pmhc_characterization$calculate_agretopicity$blastp_db_dir = "\${params.ref_dir}/antigen.garnish"
params.lens$pmhc_characterization$calculate_agretopicity$peps_and_alleles_to_antigen_stats$antigen_tool = 'mhcflurry'
params.lens$pmhc_characterization$calculate_agretopicity$peps_and_alleles_to_antigen_stats$antigen_tool_parameters = '[]'
params.lens$pmhc_characterization$calculate_agretopicity$peps_and_alleles_to_antigen_stats$antigen_tool_ref_dir = "['mhcflurry': \\"\${params.ref_dir}/mhcflurry\\"]"
params.lens$pmhc_characterization$calculate_agretopicity$peps_and_alleles_to_antigen_stats$peptide_lengths = '8,9,10,11'

# Peptide Quantification
params.lens$lenstools$lenstools_get_snv_peptide_read_count$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"
params.lens$lenstools$lenstools_get_indel_peptide_read_count$gtf = "\${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf"

# Non-CTA Self Peptide Filtering
params.lens$lenstools$lenstools_filter_mutant_peptides$pep_ref = "\${params.ref_dir}/gencode.v37.pc_translations.fa"

# pMHC Filtering
params.lens$lenstools$lenstools_annotate_pmhcs$binding_affinity_threshold = 500

# Relevant Metadata
params.lens$lenstools$annotate_ctas$cta_external_ref = "\${params.ref_dir}/canonical_txs.mtec.norm.subcell.annot.tsv"
params.lens$lenstools$annotate_ervs$erv_external_ref = "\${params.ref_dir}/erv_scores.25SEP2023.tsv"
params.lens$lenstools$annotate_erv_peptides$erv_not_in_norm_peptides = "\${params.ref_dir}/ervs_not_in_norm.peptides.tsv"

# QC
params.lens$qc$bams_to_sample_swap_check$sample_swap_tool = 'somalier'
params.lens$qc$bams_to_sample_swap_check$sample_swap_tool_dna_ref = "\${params.ref_dir}/Homo_sapiens.assembly38.fa"
params.lens$qc$bams_to_sample_swap_check$sample_swap_tool_known_sites = "\${params.ref_dir}/somalier.sites.hg38.vcf.gz"
params.lens$qc$bams_to_sample_swap_check$sample_swap_tool_parameters = "[]"

# Binfotron
params.binfotron_image = "benjaminvincentlab/rserver-binfotron:4.2.1.59"

# LENS Version
params.lens$lenstools_make_lens_report$lens_version = 'lens-v1.8'
`;

        // API configuration
        const API_BASE = window.location.origin;

        // Container label mappings (loaded from server)
        let containerLabelMappings = {};

        // Load container mappings from server
        async function loadContainerMappings() {
            try {
                const response = await fetch(`${API_BASE}/api/container-mappings`);
                if (response.ok) {
                    const data = await response.json();
                    containerLabelMappings = data.mappings || {};
                    console.log('Loaded container mappings:', containerLabelMappings);
                }
            } catch (e) {
                console.warn('Failed to load container mappings:', e);
            }
        }

        // Resolve tool name to label name for nextflow.config
        function resolveContainerLabel(toolName, species = 'human') {
            if (containerLabelMappings[toolName]) {
                const mapping = containerLabelMappings[toolName];
                if (typeof mapping === 'object') {
                    // Species-dependent mapping
                    return mapping[species] || mapping['default'] || toolName;
                }
                return mapping;
            }
            return toolName;
        }

        // State management
        const state = {
            workflow: null,
            species: null,
            startingData: null,
            version: null,
            config: {},
            toolSelections: {},
            parameterValues: {}
        };

        // Parse URL parameters for pre-population
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                workflow: params.get('workflow') || '',
                version: params.get('version') || '',
                species: params.get('species') || '',
                startingData: params.get('startingData') || ''
            };
        }

        // Initialize form from URL parameters
        function initializeFromUrl() {
            const params = getUrlParams();

            if (params.workflow) {
                document.getElementById('workflowType').value = params.workflow;
                // Trigger change event to populate versions
                const event = new Event('change');
                document.getElementById('workflowType').dispatchEvent(event);
            }
            if (params.species) {
                document.getElementById('species').value = params.species;
            }
            if (params.startingData) {
                document.getElementById('startingData').value = params.startingData;
            }
            // Set version after a short delay to allow version dropdown to populate
            if (params.version) {
                setTimeout(() => {
                    const versionValue = params.version.startsWith(params.workflow)
                        ? params.version
                        : `${params.workflow}-${params.version}`;
                    document.getElementById('workflowVersion').value = versionValue;
                }, 100);
            }
        }

        // Auto-save state to server
        async function autoSaveState() {
            try {
                await fetch(`${API_BASE}/api/autosave`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        state: {
                            ...state,
                            configOutput: document.getElementById('configOutput')?.value || '',
                            timestamp: new Date().toISOString()
                        }
                    })
                });
            } catch (error) {
                console.warn('Auto-save failed:', error);
            }
        }

        // Save config to RAFT project and signal completion
        async function saveConfigToRaft() {
            const configContent = document.getElementById('configOutput').value;
            if (!configContent) {
                alert('Please generate a configuration first.');
                return;
            }

            const saveBtn = document.getElementById('saveToRaft');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;

            try {
                // Save config to session directory
                const saveResponse = await fetch(`${API_BASE}/api/save-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ content: configContent })
                });

                if (!saveResponse.ok) {
                    throw new Error('Failed to save config');
                }

                // Signal completion
                const completeResponse = await fetch(`${API_BASE}/api/complete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'use' })
                });

                if (!completeResponse.ok) {
                    throw new Error('Failed to signal completion');
                }

                saveBtn.textContent = 'Saved! You can close this window.';
                saveBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                saveBtn.classList.add('bg-green-600');

                // Try to close the window after a short delay
                setTimeout(() => {
                    window.close();
                }, 1500);

            } catch (error) {
                console.error('Save failed:', error);
                saveBtn.textContent = 'Save failed. Try again.';
                saveBtn.disabled = false;
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                }, 2000);
            }
        }

        // Start auto-save interval
        setInterval(autoSaveState, 5000);

        // Recommended tool versions from LENS v1.8
        const recommendedToolVersions = {
            'abra2': '2.24',
            'altanalyze': '0.7.0.1-fix-nowd',
            'antigen.garnish': '2.3.0',
            'arcas-hla': '0.6.0',
            'arcashla': '0.6.0',
            'arriba': '2.4.0',
            'bam-readcount': '1.0.1',
            'bamreadcount': '1.0.1',
            'bbmap': '39.17',
            'bcftools': '1.21',
            'bedtools': '2.31.1',
            'blast': '2.16.0',
            'bowtie2': '2.5.4',
            'bwa': '0.7.8',
            'bwa-mem2': '2.2.1',
            'bwamem2': '2.2.1',
            'bwasamtools': '0.7.17-1.10',
            'cloud-sdk-ps': '495.0.0',
            'cloudsdkps': '495.0.0',
            'cnvkit': '0.9.12',
            'deephlapan': 'v1.1',
            'deepsomatic': '1.8.0',
            'deepvariant': '1.8.0',
            'fastp': '0.24.0',
            'fusioncatcher': '1.33',
            'gatk4': '4.6.1.0',
            'gffread': '0.12.7',
            'ggplot2-csvkit': '1.0',
            'ggplot2csvkit': '1.0',
            'gtfparse': '1.0.7',
            'hisat2': '2.2.1',
            'hisat2_samtools': '2.2.1',
            'hisat2samtools': '2.2.1',
            'hlapollo': 'latest',
            'hlaprofiler': '1.0.5',
            'htslib': '1.9',
            'htslib-gawk': '1.17-5.3.0',
            'htslibgawk': '1.17-5.3.0',
            'igv-reports': '1.14.1',
            'igvreports': '1.14.1',
            'jacquard': '1.1.5',
            'jq': '1.6',
            'kallisto': '0.51.1',
            'lenstools': '1.8',
            'lenstools_r': '1.8',
            'lenstoolsr': '1.8',
            'lohhla': 'v1.6',
            'longgf': 'latest',
            'mapquik': '1.0',
            'mhcflurry': '2.1.1',
            'minimap2': '2.28',
            'minimap2_samtools': '2.22_1.12',
            'minimap2samtools': '2.22_1.12',
            'mixcr': '3.0.13.1',
            'mm2_fast': '2.24',
            'mm2fast': '2.24',
            'neosplice': '1.5.1.3',
            'neosplice_search_bam': '1.0',
            'neosplicesearchbam': '1.0',
            'ngmlr': '0.2.7',
            'optitype': '1.3.5',
            'pepsickle': '0.2.1',
            'picard': '3.3.0',
            'pyclone-vi': '0.1.6',
            'pyclonevi': '0.1.6',
            'r-minimal': '4.5',
            'r-sequenza': '3.0.0',
            'rminimal': '4.5',
            'rsequenza': '3.0.0',
            'rserver-binfotron': '4.2.1.59',
            'rserverbinfotron': '4.2.1.59',
            'salmon': '1.10.3',
            'samblaster': '0.1.26',
            'samtools': '1.21',
            'samtools_mpileup_parallel': '1.17',
            'samtoolsmpileupparallel': '1.17',
            'seq2hla': '2.2',
            'seqtk': '1.4',
            'sequenza-utils': '3.0.0',
            'sequenzautils': '3.0.0',
            'sequenza_r': '3.0.0',
            'sequenza_utils': '3.0.0',
            'snaf': '0.7.0-lens-compat-mhcflurry',
            'snpeff': 'latest',
            'snpsift': '5.2',
            'snaf': '0.7.0-lens-compat-mhcflurry',
            'somalier': '0.2.19',
            'spladder': '3.0.3',
            'squid': '1.5',
            'star': '2.7.3a',
            'star-fusion': '1.14.0',
            'starfusion': '1.8.1b',
            'strelka': '2.9.7',
            'subjoin': '1.26',
            'tidyestimate': '1.1.0',
            'trim-galore': '0.6.10',
            'trimgalore': '0.6.10',
            'trimmomatic': '0.39',
            'tximport': '202306-937afa0',
            'ucsc-gtftogenepred': '377',
            'ucscgtftogenepred': '377',
            'varscan': '2.4.6',
            'vcf2maf': '112.0-cache',
            'vdjer': '1.0',
            'virdetect': '0.9.2',
            'whatshap': '2.4'
        };

        // Mock DockerHub data from LENS v1.8
        const mockDockerHubData = {
            'altanalyze': {
                account: 'spvensko',
                repo: 'altanalyze',
                versions: ['0.7.0.1-fix-nowd'],
                isOfficial: false
            },
            'antigen.garnish': {
                account: 'andrewrech',
                repo: 'antigen.garnish',
                versions: ['2.3.0'],
                isOfficial: false
            },
            'bwasamtools': {
                account: 'michaelfranklin',
                repo: 'bwasamtools',
                versions: ['0.7.17-1.10'],
                isOfficial: false
            },
            'cloud-sdk-ps': {
                account: 'spvensko',
                repo: 'cloud-sdk-ps',
                versions: ['495.0.0'],
                isOfficial: false
            },
            'cloudsdkps': {
                account: 'spvensko',
                repo: 'cloud-sdk-ps',
                versions: ['495.0.0'],
                isOfficial: false
            },
            'deephlapan': {
                account: 'biopharm',
                repo: 'deephlapan',
                versions: ['v1.1'],
                isOfficial: false
            },
            'ggplot2-csvkit': {
                account: 'spvensko',
                repo: 'ggplot2-csvkit',
                versions: ['1.0'],
                isOfficial: false
            },
            'ggplot2csvkit': {
                account: 'spvensko',
                repo: 'ggplot2-csvkit',
                versions: ['1.0'],
                isOfficial: false
            },
            'hisat2_samtools': {
                account: 'danielapeterson',
                repo: 'hisat2_samtools',
                versions: ['2.2.1'],
                isOfficial: false
            },
            'hisat2samtools': {
                account: 'danielapeterson',
                repo: 'hisat2_samtools',
                versions: ['2.2.1'],
                isOfficial: false
            },
            'hlapollo': {
                account: 'spvensko',
                repo: 'hlapollo',
                versions: ['latest'],
                isOfficial: false
            },
            'htslib-gawk': {
                account: 'spvensko',
                repo: 'htslib-gawk',
                versions: ['1.17-5.3.0'],
                isOfficial: false
            },
            'htslibgawk': {
                account: 'spvensko',
                repo: 'htslib-gawk',
                versions: ['1.17-5.3.0'],
                isOfficial: false
            },
            'jacquard': {
                account: 'spvensko',
                repo: 'jacquard',
                versions: ['1.1.5'],
                isOfficial: false
            },
            'lenstools': {
                account: 'spvensko',
                repo: 'lenstools',
                versions: ['1.8'],
                isOfficial: false
            },
            'lenstools_r': {
                account: 'spvensko',
                repo: 'lenstools_r',
                versions: ['1.8'],
                isOfficial: false
            },
            'lenstoolsr': {
                account: 'spvensko',
                repo: 'lenstools_r',
                versions: ['1.8'],
                isOfficial: false
            },
            'lohhla': {
                account: 'brianp9397',
                repo: 'lohhla',
                versions: ['v1.6'],
                isOfficial: false
            },
            'longgf': {
                account: 'docker://trinityctat',
                repo: 'longgf',
                versions: ['latest'],
                isOfficial: false
            },
            'mapquik': {
                account: 'spvensko',
                repo: 'mapquik',
                versions: ['1.0'],
                isOfficial: false
            },
            'mhcflurry': {
                account: 'spvensko',
                repo: 'mhcflurry',
                versions: ['2.1.1', '2.1.0', '2.0.6', '2.0.5'],
                isOfficial: false
            },
            'minimap2_samtools': {
                account: 'niemasd',
                repo: 'minimap2_samtools',
                versions: ['2.22_1.12'],
                isOfficial: false
            },
            'minimap2samtools': {
                account: 'niemasd',
                repo: 'minimap2_samtools',
                versions: ['2.22_1.12'],
                isOfficial: false
            },
            'mixcr': {
                account: 'benjaminvincentlab',
                repo: 'mixcr',
                versions: ['3.0.13.1'],
                isOfficial: false
            },
            'mm2_fast': {
                account: 'spvensko',
                repo: 'mm2_fast',
                versions: ['2.24'],
                isOfficial: false
            },
            'mm2fast': {
                account: 'spvensko',
                repo: 'mm2_fast',
                versions: ['2.24'],
                isOfficial: false
            },
            'neosplice': {
                account: 'spvensko',
                repo: 'neosplice',
                versions: ['1.5.1.3', '1.5.1.2', '1.5.1.1', '0.1.3'],
                isOfficial: false
            },
            'neosplice_search_bam': {
                account: 'spvensko',
                repo: 'neosplice_search_bam',
                versions: ['1.0'],
                isOfficial: false
            },
            'neosplicesearchbam': {
                account: 'spvensko',
                repo: 'neosplice_search_bam',
                versions: ['1.0'],
                isOfficial: false
            },
            'pepsickle': {
                account: 'spvensko',
                repo: 'pepsickle',
                versions: ['0.2.1'],
                isOfficial: false
            },
            'r-minimal': {
                account: 'rhub',
                repo: 'r-minimal',
                versions: ['4.5'],
                isOfficial: false
            },
            'rminimal': {
                account: 'rhub',
                repo: 'r-minimal',
                versions: ['4.5'],
                isOfficial: false
            },
            'rserver-binfotron': {
                account: 'benjaminvincentlab',
                repo: 'rserver-binfotron',
                versions: ['4.2.1.59'],
                isOfficial: false
            },
            'rserverbinfotron': {
                account: 'benjaminvincentlab',
                repo: 'rserver-binfotron',
                versions: ['4.2.1.59'],
                isOfficial: false
            },
            'samblaster': {
                account: 'spvensko',
                repo: 'samblaster',
                versions: ['0.1.26'],
                isOfficial: false
            },
            'samtools_mpileup_parallel': {
                account: 'spvensko',
                repo: 'samtools_mpileup_parallel',
                versions: ['1.17'],
                isOfficial: false
            },
            'samtoolsmpileupparallel': {
                account: 'spvensko',
                repo: 'samtools_mpileup_parallel',
                versions: ['1.17'],
                isOfficial: false
            },
            'snaf': {
                account: 'spvensko',
                repo: 'snaf',
                versions: ['0.7.0-lens-compat-mhcflurry'],
                isOfficial: false
            },
            'snpeff': {
                account: 'resolwebio',
                repo: 'snpeff',
                versions: ['latest'],
                isOfficial: false
            },
            'spladder': {
                account: 'gcfntnu',
                repo: 'spladder',
                versions: ['3.0.3'],
                isOfficial: false
            },
            'squid': {
                account: 'docker://spvensko',
                repo: 'squid',
                versions: ['1.5'],
                isOfficial: false
            },
            'starfusion': {
                account: 'trinityctat',
                repo: 'starfusion',
                versions: ['1.8.1b'],
                isOfficial: false
            },
            'subjoin': {
                account: 'spvensko',
                repo: 'subjoin',
                versions: ['1.26'],
                isOfficial: false
            },
            'tidyestimate': {
                account: 'spvensko',
                repo: 'tidyestimate',
                versions: ['1.1.0'],
                isOfficial: false
            },
            'tximport': {
                account: 'pmbku',
                repo: 'tximport',
                versions: ['202306-937afa0'],
                isOfficial: false
            },
            'vcf2maf': {
                account: 'spvensko',
                repo: 'vcf2maf',
                versions: ['112.0-cache'],
                isOfficial: false
            },
            'vdjer': {
                account: 'm0zack',
                repo: 'vdjer',
                versions: ['1.0'],
                isOfficial: false
            },
            'virdetect': {
                account: 'spvensko',
                repo: 'virdetect',
                versions: ['0.9.2', '0.9.1', '0.9.0'],
                isOfficial: false
            }
        };

        // Mock BioContainers fallback data from LENS v1.8
        const mockBiocontainerVersions = {
            'abra2': ['2.24', '2.23', '2.22'],
            'arcas-hla': ['0.6.0', '0.5.0', '0.4.0'],
            'arcashla': ['0.6.0', '0.5.0', '0.4.0'],
            'arriba': ['2.4.0', '2.3.0', '2.2.1'],
            'bam-readcount': ['1.0.1', '1.0.0'],
            'bamreadcount': ['1.0.1', '1.0.0'],
            'bbmap': ['39.17', '39.01', '38.96'],
            'bcftools': ['1.21', '1.20', '1.19'],
            'bedtools': ['2.31.1', '2.31.0', '2.30.0'],
            'blast': ['2.16.0', '2.15.0', '2.14.1'],
            'bowtie2': ['2.5.4', '2.5.3', '2.5.2'],
            'bwa': ['0.7.8', '0.7.17', '0.7.16'],
            'bwa-mem2': ['2.2.1', '2.2.0', '2.1.0'],
            'bwamem2': ['2.2.1', '2.2.0', '2.1.0'],
            'cnvkit': ['0.9.12', '0.9.11', '0.9.10'],
            'cutadapt': ['4.9', '4.8', '4.7', '4.6'],
            'deepvariant': ['1.8.0', '1.7.0', '1.6.1', '1.6.0'],
            'deepsomatic': ['1.8.0', '1.7.0', '1.6.1'],
            'fastp': ['0.24.0', '0.23.4', '0.23.2'],
            'fusioncatcher': ['1.33', '1.32', '1.31'],
            'gatk4': ['4.6.1.0', '4.6.0.0', '4.5.0.0'],
            'gffread': ['0.12.7', '0.12.6', '0.12.5'],
            'gtfparse': ['1.0.7', '1.0.6', '1.0.5'],
            'hisat2': ['2.2.1', '2.2.0', '2.1.0'],
            'hlaprofiler': ['1.0.5', '1.0.4', '1.0.3'],
            'htslib': ['1.9', '1.8', '1.7'],
            'igv-reports': ['1.14.1', '1.14.0', '1.13.0'],
            'igvreports': ['1.14.1', '1.14.0', '1.13.0'],
            'jq': ['1.6', '1.5'],
            'kallisto': ['0.51.1', '0.50.1', '0.50.0'],
            'minimap2': ['2.28', '2.27', '2.26'],
            'mutect2': ['4.6.1.0', '4.6.0.0', '4.5.0.0'],
            'ngmlr': ['0.2.7', '0.2.6'],
            'optitype': ['1.3.5', '1.3.4', '1.3.3'],
            'optitype_rna': ['1.3.5', '1.3.4', '1.3.3'],
            'optitype_dna': ['1.3.5', '1.3.4', '1.3.3'],
            'picard': ['3.3.0', '3.2.0', '3.1.1'],
            'pyclone-vi': ['0.1.6', '0.1.5'],
            'pyclonevi': ['0.1.6', '0.1.5'],
            'r-sequenza': ['3.0.0', '2.2.0'],
            'rsequenza': ['3.0.0', '2.2.0'],
            'salmon': ['1.10.3', '1.10.2', '1.10.1', '1.10.0'],
            'samblaster': ['0.1.26', '0.1.25', '0.1.24'],
            'samtools': ['1.21', '1.20', '1.19'],
            'seq2hla': ['2.2', '2.1'],
            'seq2hla_ase': ['2.2', '2.1'],
            'seqtk': ['1.4', '1.3'],
            'sequenza-utils': ['3.0.0', '2.2.0'],
            'sequenzautils': ['3.0.0', '2.2.0'],
            'sequenza_r': ['3.0.0', '2.2.0'],
            'sequenza_utils': ['3.0.0', '2.2.0'],
            'snpsift': ['5.2', '5.1', '5.0'],
            'somalier': ['0.2.19', '0.2.18', '0.2.17'],
            'star': ['2.7.3a', '2.7.11b', '2.7.10b', '2.7.9a'],
            'star-fusion': ['1.14.0', '1.13.0', '1.12.0'],
            'starfusion': ['1.14.0', '1.13.0', '1.12.0'],
            'strelka': ['2.9.7', '2.9.10', '2.9.9'],
            'strelka2': ['2.9.10', '2.9.9', '2.9.7'],
            'trim-galore': ['0.6.10', '0.6.9', '0.6.8'],
            'trimgalore': ['0.6.10', '0.6.9', '0.6.8'],
            'trimmomatic': ['0.39', '0.38', '0.36'],
            'ucsc-gtftogenepred': ['377', '366'],
            'ucscgtftogenepred': ['377', '366'],
            'varscan': ['2.4.6', '2.4.5', '2.4.4'],
            'varscan2': ['2.4.6', '2.4.5', '2.4.4'],
            'whatshap': ['2.4', '2.3', '2.2']
        };

        // Cache for BioContainers API results
        const biocontainersCache = {};
        
        // Track which subsections have been visited
        const visitedSubsections = new Set();
        
        // Tools known to not have biocontainers entries
        const nonBiocontainerTools = new Set([
            'netmhcpan', 
            'netmhcstabpan', 
            'netmhciipan',
            'mhcflurry',
            'optitype',
            'arcashla'
        ]);
        
        // Preferred DockerHub accounts for specific tools
        const preferredDockerHubAccounts = {
            'mhcflurry': ['openvax'],
            'netmhcpan': ['dceoy'],
            'netmhcstabpan': ['dceoy'],
            'optitype': ['fred2'],
            'arcashla': ['nmdpbioinformatics']
        };

        /**
         * Search DockerHub for a tool and return best matching images
         * @param {string} toolName - Name of the tool
         * @returns {Promise<Object|null>} - Object with {account, versions, isOfficial: false} or null
         */
        async function searchDockerHub(toolName) {
            try {
                // First, try preferred accounts if defined
                const preferredAccounts = preferredDockerHubAccounts[toolName] || [];
                
                for (const account of preferredAccounts) {
                    const result = await fetchDockerHubRepo(account, toolName);
                    if (result && result.versions.length > 0) {
                        return result;
                    }
                }
                
                // If no preferred account worked, search DockerHub
                const searchUrl = `https://hub.docker.com/api/content/v1/products/search?q=${encodeURIComponent(toolName)}&type=image&page_size=10`;
                const response = await fetch(searchUrl);
                
                if (!response.ok) {
                    console.warn(`DockerHub search failed for ${toolName}`);
                    return null;
                }
                
                const data = await response.json();
                
                // Filter results to find relevant images
                const relevantImages = data.summaries
                    ?.filter(img => {
                        const repoName = img.slug?.toLowerCase() || '';
                        return repoName.includes(toolName.toLowerCase());
                    })
                    .sort((a, b) => (b.pull_count || 0) - (a.pull_count || 0)); // Sort by pulls
                
                if (!relevantImages || relevantImages.length === 0) {
                    return null;
                }
                
                // Try the top result
                const topImage = relevantImages[0];
                const [account, repo] = topImage.slug.split('/');
                
                return await fetchDockerHubRepo(account, repo);
                
            } catch (error) {
                console.error(`Error searching DockerHub for ${toolName}:`, error);
                return null;
            }
        }
        
        /**
         * Fetch tags from a specific DockerHub repository
         * @param {string} account - DockerHub account name
         * @param {string} repo - Repository name
         * @returns {Promise<Object|null>} - Object with {account, repo, versions, isOfficial: false}
         */
        async function fetchDockerHubRepo(account, repo) {
            try {
                const tagsUrl = `https://hub.docker.com/v2/repositories/${account}/${repo}/tags?page_size=100`;
                const response = await fetch(tagsUrl);
                
                if (!response.ok) {
                    return null;
                }
                
                const data = await response.json();
                
                // Extract versions from tags
                const versions = data.results
                    ?.map(tag => {
                        const tagName = tag.name;
                        // Match semantic versions (e.g., 2.1.3, 1.0.0, 4.1)
                        const versionMatch = tagName.match(/^v?(\d+\.\d+\.?\d*)$/);
                        return versionMatch ? versionMatch[1] : null;
                    })
                    .filter(v => v !== null)
                    .filter((v, i, arr) => arr.indexOf(v) === i) // Remove duplicates
                    .sort((a, b) => {
                        // Sort by version number (descending)
                        const aParts = a.split('.').map(p => parseInt(p) || 0);
                        const bParts = b.split('.').map(p => parseInt(p) || 0);
                        
                        for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                            const aVal = aParts[i] || 0;
                            const bVal = bParts[i] || 0;
                            if (aVal !== bVal) return bVal - aVal;
                        }
                        return 0;
                    })
                    .slice(0, 10); // Keep top 10 versions
                
                if (versions.length > 0) {
                    return {
                        account,
                        repo,
                        versions,
                        isOfficial: false
                    };
                }
                
                return null;
                
            } catch (error) {
                console.error(`Error fetching DockerHub repo ${account}/${repo}:`, error);
                return null;
            }
        }

        /**
         * Fetch container versions from BioContainers (quay.io)
         * @param {string} toolName - Name of the tool
         * @returns {Promise<Object|null>} - Object with {versions, isOfficial: true} or null
         */
        async function fetchBiocontainerVersions(toolName) {
            // Check if this tool is known to not be in biocontainers
            if (nonBiocontainerTools.has(toolName)) {
                // Check mock DockerHub data first
                if (mockDockerHubData[toolName]) {
                    biocontainersCache[toolName] = mockDockerHubData[toolName];
                    return mockDockerHubData[toolName];
                }
                
                biocontainersCache[toolName] = null;
                return null;
            }

            // Check cache first
            if (biocontainersCache.hasOwnProperty(toolName)) {
                return biocontainersCache[toolName];
            }

            try {
                // Query quay.io API for biocontainers
                const url = `https://quay.io/api/v1/repository/biocontainers/${toolName}/tag/`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    console.warn(`Tool ${toolName} not found in BioContainers, checking DockerHub...`);
                    
                    // Try mock DockerHub data first (for offline/restricted environments)
                    if (mockDockerHubData[toolName]) {
                        biocontainersCache[toolName] = mockDockerHubData[toolName];
                        return mockDockerHubData[toolName];
                    }
                    
                    // Try DockerHub API as fallback
                    const dockerHubResult = await searchDockerHub(toolName);
                    if (dockerHubResult) {
                        biocontainersCache[toolName] = dockerHubResult;
                        return dockerHubResult;
                    }
                    
                    biocontainersCache[toolName] = null;
                    return null;
                }

                const data = await response.json();
                
                // Extract and parse versions
                const versions = data.tags
                    .map(tag => {
                        const match = tag.name.match(/^([0-9]+\.[0-9]+\.?[0-9]*[a-z]?)--/);
                        return match ? match[1] : null;
                    })
                    .filter(v => v !== null)
                    .filter((v, i, arr) => arr.indexOf(v) === i)
                    .sort((a, b) => {
                        const aParts = a.split('.').map(p => parseInt(p) || 0);
                        const bParts = b.split('.').map(p => parseInt(p) || 0);
                        
                        for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                            const aVal = aParts[i] || 0;
                            const bVal = bParts[i] || 0;
                            if (aVal !== bVal) return bVal - aVal;
                        }
                        return 0;
                    })
                    .slice(0, 10);

                if (versions.length > 0) {
                    const result = {
                        versions,
                        isOfficial: true
                    };
                    biocontainersCache[toolName] = result;
                    return result;
                } else {
                    // Try mock DockerHub data
                    if (mockDockerHubData[toolName]) {
                        biocontainersCache[toolName] = mockDockerHubData[toolName];
                        return mockDockerHubData[toolName];
                    }
                    
                    // Try DockerHub API as fallback
                    const dockerHubResult = await searchDockerHub(toolName);
                    if (dockerHubResult) {
                        biocontainersCache[toolName] = dockerHubResult;
                        return dockerHubResult;
                    }
                    
                    biocontainersCache[toolName] = null;
                    return null;
                }

            } catch (error) {
                console.error(`Error fetching versions for ${toolName}:`, error);
                
                // Try mock DockerHub data first
                if (mockDockerHubData[toolName]) {
                    biocontainersCache[toolName] = mockDockerHubData[toolName];
                    return mockDockerHubData[toolName];
                }
                
                // Try DockerHub API as fallback
                try {
                    const dockerHubResult = await searchDockerHub(toolName);
                    if (dockerHubResult) {
                        biocontainersCache[toolName] = dockerHubResult;
                        return dockerHubResult;
                    }
                } catch (dhError) {
                    console.error(`DockerHub fallback also failed for ${toolName}`);
                }
                
                biocontainersCache[toolName] = null;
                return null;
            }
        }

        /**
         * Batch fetch versions for multiple tools
         * @param {Array<string>} toolNames - Array of tool names
         * @returns {Promise<Object>} - Map of tool names to version arrays
         */
        async function fetchMultipleToolVersions(toolNames) {
            const results = {};
            const uniqueTools = [...new Set(toolNames)];
            
            // Fetch all tools in parallel
            const promises = uniqueTools.map(async tool => {
                results[tool] = await fetchBiocontainerVersions(tool);
            });
            
            await Promise.all(promises);
            return results;
        }

        // Initialize event listeners
        document.getElementById('loadWorkflow').addEventListener('click', loadWorkflowConfig);
        document.getElementById('copyConfig').addEventListener('click', copyConfigToClipboard);
        document.getElementById('downloadConfig').addEventListener('click', downloadConfigFile);
        document.getElementById('saveToRaft').addEventListener('click', saveConfigToRaft);
        document.getElementById('copyMethods').addEventListener('click', copyMethodsToClipboard);
        document.getElementById('downloadMethods').addEventListener('click', downloadMethodsFile);
        document.getElementById('copyMethods').addEventListener('click', copyMethodsToClipboard);
        document.getElementById('downloadMethods').addEventListener('click', downloadMethodsFile);

        // Initialize form from URL parameters on page load
        initializeFromUrl();

        // Load container mappings at startup
        loadContainerMappings();
        
        // Methods header toggle
        document.getElementById('methodsHeader').addEventListener('click', () => {
            const content = document.querySelector('.methods-output-section');
            const arrow = document.querySelector('#methodsHeader svg');
            content.classList.toggle('active');
            arrow.classList.toggle('rotate-180');
        });
        
        // Config header toggle
        document.getElementById('configHeader').addEventListener('click', () => {
            const content = document.querySelector('.config-output-section');
            const arrow = document.querySelector('#configHeader svg');
            content.classList.toggle('active');
            arrow.classList.toggle('rotate-180');
        });

        // Populate workflow versions when workflow type changes
        document.getElementById('workflowType').addEventListener('change', async (e) => {
            const versionSelect = document.getElementById('workflowVersion');
            versionSelect.innerHTML = '<option value="">Select version...</option>';
            
            if (e.target.value) {
                const versions = ['lens-v1.8', 'lens-v1.7', 'lens-v1.6'];
                versions.forEach(version => {
                    const option = document.createElement('option');
                    option.value = version;
                    option.textContent = version;
                    versionSelect.appendChild(option);
                });
                versionSelect.value = versions[0];
            }
        });

        async function loadWorkflowConfig() {
            const workflowType = document.getElementById('workflowType').value;
            const species = document.getElementById('species').value;
            const startingData = document.getElementById('startingData').value;
            const version = document.getElementById('workflowVersion').value;

            const errorDiv = document.getElementById('errorMessage');
            errorDiv.classList.add('hidden');

            if (!workflowType || !species || !startingData || !version) {
                showError('Please select all workflow parameters');
                return;
            }

            state.workflow = workflowType;
            state.species = species;
            state.startingData = startingData;
            state.version = version;

            const spinner = document.getElementById('loadingSpinner');
            spinner.classList.remove('hidden');

            try {
                // Parse config
                const workflowConfig = parseConfigFile(LENS_CONFIG_TEXT);
                
                // Collect all tool names from the config
                const allTools = new Set();
                workflowConfig.sections.forEach(section => {
                    section.subsections.forEach(subsection => {
                        subsection.steps.forEach(step => {
                            step.tools.forEach(tool => {
                                tool.options.forEach(option => {
                                    allTools.add(option.value);
                                });
                            });
                        });
                    });
                });

                // Fetch BioContainers versions for all tools
                console.log('Fetching BioContainers versions for tools:', Array.from(allTools));
                await fetchMultipleToolVersions(Array.from(allTools));
                
                renderWorkflowConfiguration(workflowConfig);
                document.getElementById('workflowConfig').classList.remove('hidden');
                
                // Expand only top-level sections, keep subsections collapsed
                document.querySelectorAll('.accordion-content').forEach(content => {
                    // Check if this is a top-level section (parent has bg-indigo-600)
                    // vs subsection (parent has bg-gray-200)
                    const header = content.previousElementSibling;
                    if (header && header.classList.contains('bg-indigo-600')) {
                        // Top-level section - expand
                        content.classList.add('active');
                        header.querySelector('svg').classList.add('rotate-180');
                    } else {
                        // Subsection - keep collapsed
                        content.classList.remove('active');
                        const svg = header?.querySelector('svg');
                        if (svg) svg.classList.remove('rotate-180');
                    }
                });
                
                generateConfigOutput();
                generateMethodsDescription();
            } catch (error) {
                showError(`Error loading workflow: ${error.message}`);
                console.error(error);
            } finally {
                spinner.classList.add('hidden');
            }
        }

        function parseConfigFile(configText) {
            const lines = configText.split('\n');
            const paramMap = {};
            
            for (const line of lines) {
                const match = line.match(/params\.([^\s=]+)\s*=\s*['"](.*)['"]/);
                if (match) {
                    const paramName = match[1];
                    const value = match[2];
                    paramMap[paramName] = value;
                }
            }
            
            return buildWorkflowStructure(paramMap);
        }

        function buildWorkflowStructure(paramMap) {
            const structure = {
                sections: []
            };
            
            // Define which parameters are workflow parameters (not tools or tool_parameters or refs)
            const workflowParamNames = [
                'combine_strategy', 
                'peptide_lengths',
                'tpm_threshold',
                'normal_control_quant',
                'binding_affinity_threshold',
                'som_var_type',
                'viral_workflow',
                'molecule_filter',
                'separator'
            ];
            
            // Look for _tool OR _caller parameters (but not _parameters variants or _ref variants or _suffix)
            const toolParams = Object.keys(paramMap).filter(k => 
                (k.includes('_tool') || k.includes('_caller')) && 
                !k.includes('_tool_parameters') && 
                !k.includes('_caller_parameters') &&
                !k.includes('_ref') &&
                !k.includes('_bed') &&
                !k.includes('_gtf') &&
                !k.includes('_known_sites') &&
                !k.includes('_suffix')
            );
            const grouped = {};
            const workflowParams = {}; // Store workflow parameters by step
            const subsectionWorkflowParams = {}; // Store subsection-level workflow parameters
            const stepReferences = {}; // Store reference parameters by step
            
            // Collect workflow parameters
            for (const key of Object.keys(paramMap)) {
                const parts = key.split('$');
                if (parts.length < 3) continue;
                
                const paramName = parts[parts.length - 1];
                
                // Check if it's a reference parameter (but NOT tool-specific refs)
                const isRef = (paramName.includes('_ref') || paramName.includes('_bed') || 
                              paramName.includes('_gtf') || paramName.includes('_gff') || 
                              paramName.includes('_known_sites')) &&
                              !paramName.includes('_tool_ref') && 
                              !paramName.includes('_caller_ref');
                
                if (isRef && parts.length === 4) {
                    // Step-level reference
                    const stepPath = parts.slice(0, 3).join('$');
                    if (!stepReferences[stepPath]) stepReferences[stepPath] = {};
                    stepReferences[stepPath][paramName] = {
                        name: paramName,
                        parameter: `params.${key}`,
                        value: (paramMap[key] || '').replace('${params.ref_dir}/', ''),
                        isReference: true
                    };
                } else if (workflowParamNames.includes(paramName)) {
                    if (parts.length === 3) {
                        // Subsection-level parameter (e.g., lens$seq_variation$combine_strategy)
                        const subsectionPath = parts.slice(0, 2).join('$');
                        if (!subsectionWorkflowParams[subsectionPath]) subsectionWorkflowParams[subsectionPath] = {};
                        subsectionWorkflowParams[subsectionPath][paramName] = {
                            name: paramName,
                            parameter: `params.${key}`,
                            value: paramMap[key]
                        };
                    } else {
                        // Step-level parameter (e.g., lens$pmhc$peps_and_alleles_to_antigen_stats$peptide_lengths)
                        const stepPath = parts.slice(0, -1).join('$');
                        if (!workflowParams[stepPath]) workflowParams[stepPath] = {};
                        workflowParams[stepPath][paramName] = {
                            name: paramName,
                            parameter: `params.${key}`,
                            value: paramMap[key]
                        };
                    }
                }
            }
            
            for (const toolParam of toolParams) {
                const parts = toolParam.split('$');
                
                let sectionName, subsectionName, stepName, toolParamName;
                
                if (parts.length === 3) {
                    // Top-level section like splice$alns_to_splice_variants$splice_var_caller
                    sectionName = parts[0];
                    subsectionName = parts[0]; // Use same name for both
                    stepName = parts[1];
                    toolParamName = parts[2];
                } else if (parts.length === 4) {
                    // Nested section like lens$alignment$manifest_to_dna_alns$fq_trim_tool
                    sectionName = parts[0];
                    subsectionName = parts[1];
                    stepName = parts[2];
                    toolParamName = parts[3];
                } else {
                    continue; // Skip malformed parameters
                }
                
                if (!grouped[sectionName]) grouped[sectionName] = {};
                if (!grouped[sectionName][subsectionName]) grouped[sectionName][subsectionName] = {};
                if (!grouped[sectionName][subsectionName][stepName]) grouped[sectionName][subsectionName][stepName] = [];
                
                const toolValue = paramMap[toolParam];
                const toolParamValue = paramMap[`${toolParam}_parameters`] || '[]';
                const toolRefValue = paramMap[`${toolParam}_ref`] || paramMap[`${toolParam}_refs`] || 
                                    paramMap[`${toolParam}_ref_dir`] || '';
                
                grouped[sectionName][subsectionName][stepName].push({
                    name: toolParamName,
                    parameter: `params.${toolParam}`,
                    parameterField: `params.${toolParam}_parameters`,
                    toolRefField: toolRefValue ? `params.${toolParam}_ref` : null,
                    default: toolValue,
                    defaultParams: parseToolParameters(toolParamValue, toolValue),
                    toolRefs: parseToolRefs(toolRefValue, toolValue)
                });
            }
            
            // Convert to structure
            for (const [sectionName, subsections] of Object.entries(grouped)) {
                const section = {
                    name: sectionName,
                    displayName: humanReadableName(sectionName),
                    subsections: []
                };
                
                for (const [subsectionName, steps] of Object.entries(subsections)) {
                    // Get subsection-level workflow parameters
                    const subsectionPath = `${sectionName}$${subsectionName}`;
                    const subsectionParams = subsectionWorkflowParams[subsectionPath] || {};
                    
                    const subsection = {
                        name: subsectionName,
                        displayName: humanReadableName(subsectionName),
                        workflowParams: Object.values(subsectionParams), // Add subsection-level parameters
                        steps: []
                    };
                    
                    for (const [stepName, tools] of Object.entries(steps)) {
                        // Get workflow parameters for this step
                        const stepPath = `${sectionName}$${subsectionName}$${stepName}`;
                        const stepWorkflowParams = workflowParams[stepPath] || {};
                        const stepRefs = stepReferences[stepPath] || {};
                        
                        // Combine workflow params and references
                        const allStepParams = [...Object.values(stepWorkflowParams), ...Object.values(stepRefs)];
                        
                        const step = {
                            name: stepName,
                            displayName: humanReadableName(stepName),
                            parameter: `params.${sectionName}$${subsectionName}$${stepName}`,
                            workflowParams: allStepParams, // Add workflow parameters and references
                            tools: tools.map(tool => ({
                                ...tool,
                                displayName: humanReadableName(tool.name),
                                multiSelect: true,
                                singleUse: isSingleUseTool(tool.name),
                                options: getToolOptions(tool.name, tool.default),
                                warning: isSingleUseTool(tool.name) ? 
                                    'Only the first selected tool will be used for downstream analysis. Additional tools will run but their outputs will not be passed forward.' : 
                                    null
                            }))
                        };
                        
                        subsection.steps.push(step);
                    }
                    
                    section.subsections.push(subsection);
                }
                
                // Add References subsection to LENS section
                if (sectionName === 'lens') {
                    const referencesSubsection = {
                        name: 'references',
                        displayName: 'References',
                        workflowParams: [
                            {
                                name: 'aln_ref',
                                parameter: 'params.global_aln_ref',
                                value: (paramMap['lens$alignment$manifest_to_dna_alns$aln_ref'] || '${params.ref_dir}/Homo_sapiens.assembly38.fa').replace('${params.ref_dir}/', ''),
                                description: 'Main genome reference (FASTA)',
                                isReference: true
                            },
                            {
                                name: 'gtf',
                                parameter: 'params.global_gtf',
                                value: (paramMap['lens$alignment$manifest_to_dna_alns$gtf'] || '${params.ref_dir}/gencode.v37.annotation.with.hervs.gtf').replace('${params.ref_dir}/', ''),
                                description: 'Gene annotation (GTF)',
                                isReference: true
                            },
                            {
                                name: 'bed',
                                parameter: 'params.global_bed',
                                value: (paramMap['lens$alignment$alns_to_dna_procd_alns$bed'] || '${params.ref_dir}/hg38_exome.bed').replace('${params.ref_dir}/', ''),
                                description: 'Target regions (BED)',
                                isReference: true
                            },
                            {
                                name: 'known_sites_ref',
                                parameter: 'params.global_known_sites',
                                value: (paramMap['lens$alignment$alns_to_dna_procd_alns$known_sites_ref'] || '${params.ref_dir}/Homo_sapiens_assembly38.dbsnp138.vcf.gz').replace('${params.ref_dir}/', ''),
                                description: 'Known variants (VCF)',
                                isReference: true
                            }
                        ],
                        steps: []
                    };
                    section.subsections.push(referencesSubsection);
                }
                
                // Sort subsections: references first, qc second, pmhc_characterization last
                section.subsections.sort((a, b) => {
                    if (a.name === 'references') return -1;
                    if (b.name === 'references') return 1;
                    if (a.name === 'qc') return -1;
                    if (b.name === 'qc') return 1;
                    if (a.name === 'pmhc_characterization') return 1;
                    if (b.name === 'pmhc_characterization') return -1;
                    return 0;
                });
                
                structure.sections.push(section);
            }
            
            return structure;
        }
        
        function parseToolRefs(refString, toolsList) {
            const refs = {};
            
            if (!refString || refString === '[]' || refString === "''") {
                return refs;
            }
            
            // Parse format like ['tool': 'path', 'tool2': 'path2']
            const match = refString.match(/\['([^']+)':\s*[\\]*"([^"\\]+)[\\]*"/g);
            if (match) {
                match.forEach(item => {
                    const toolMatch = item.match(/'([^']+)':\s*[\\]*"([^"\\]+)[\\]*"/);
                    if (toolMatch) {
                        const tool = toolMatch[1];
                        const path = toolMatch[2].replace(/\$\{params\.ref_dir\}\//, '');
                        refs[tool] = path;
                    }
                });
            }
            
            return refs;
        }

        function parseToolParameters(paramString, toolsList) {
            const params = {};
            
            if (paramString === '[]') {
                const tools = toolsList.split(',').map(t => t.trim());
                for (const tool of tools) {
                    params[tool] = '';
                }
                return params;
            }
            
            const match = paramString.match(/\[(.*)\]/);
            if (!match) return params;
            
            const inner = match[1];
            const tools = toolsList.split(',').map(t => t.trim());
            
            if (inner.includes(':')) {
                const pairs = inner.split(',');
                for (const pair of pairs) {
                    const colonIdx = pair.indexOf(':');
                    if (colonIdx > 0) {
                        const tool = pair.substring(0, colonIdx).trim().replace(/['"]/g, '');
                        const value = pair.substring(colonIdx + 1).trim().replace(/['"]/g, '');
                        params[tool] = value;
                    }
                }
            } else {
                for (const tool of tools) {
                    params[tool] = inner.replace(/['"]/g, '');
                }
            }
            
            return params;
        }

        function humanReadableName(name) {
            // Custom mappings for specific sections
            const customMappings = {
                'somatic': 'Somatic Variation',
                'germline': 'Germline Variation',
                'seq_variation': 'Variant Merging and Phasing',
                'indel': 'InDel',
                'fusion': 'Gene Fusions',
                'splice': 'Splice Variation',
                'immuno': 'MHC Typing',
                'pmhc_characterization': 'Peptide/MHC Characterization',
                'tumor_purity': 'Tumor Purity',
                'copy_number_alterations': 'Copy Number Alterations',
                'hla_loh': 'HLA Loss of Heterozygosity',
                'qc': 'Quality Control',
                'loh': 'LOH',
                'procd_fqs_to_rna_mhc_alleles': 'RNA-derived MHC Alleles',
                'procd_fqs_to_dna_mhc_alleles': 'DNA-derived MHC Alleles',
                'som_vars_to_hi_conf_som_vars': 'Somatic Variants to High Confidence Somatic Variants',
                'make_phased_tumor_vars': 'Make Phased Tumor Variants',
                'alns_to_tumor_purities': 'Alignments to Tumor Purities',
                'combine_strategy': 'Somatic Variant Combination Strategy',
                'aln_ref': 'Alignment Reference',
                'gtf': 'GTF',
                'bed': 'BED',
                'known_sites_ref': 'Known Sites Reference'
            };
            
            if (customMappings[name]) {
                return customMappings[name];
            }
            
            const replacements = {
                'fq': 'FASTQ',
                'aln': 'Alignment',
                'dna': 'DNA',
                'rna': 'RNA',
                'som': 'Somatic',
                'germ': 'Germline',
                'var': 'Variant',
                'vars': 'Variants',
                'hla': 'HLA',
                'loh': 'LOH',
                'tx': 'Transcript',
                'quant': 'Quantification',
                'procd': 'Processed',
                'fqs': 'FASTQs',
                'alns': 'Alignments',
                'peps': 'Peptides',
                'pmhc': 'pMHC',
                'pmhcs': 'pMHCs',
                'typer': 'Typing',
                'indel': 'InDel',
                'realign': 'Realignment',
                'hi': 'High',
                'conf': 'Confidence',
                'vcf': 'VCF',
                'isecing': 'Intersection',
                'isecd': 'Intersection',
                'filtd': 'Filtered',
                'normd': 'Normalized',
                'union': 'Union',
                'bqsr': 'BQSR',
                'qc': 'QC',
                'cna': 'CNA',
                'cnas': 'CNAs',
                'dup': 'Duplicate'
            };
            
            return name
                .split('_')
                .map(word => replacements[word] || word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function isSingleUseTool(toolName) {
            const singleUseTools = ['fq_trim_tool', 'aln_tool', 'dup_marker_tool', 'base_recalibrator_tool', 'indel_realign_tool', 'tx_quant_tool'];
            return singleUseTools.includes(toolName);
        }

        function getToolOptions(toolName, defaultValue) {
            const toolOptionMap = {
                'fq_trim_tool': ['fastp', 'trimmomatic', 'cutadapt'],
                'aln_tool': ['bwa', 'bwa-mem2', 'bbmap', 'minimap2', 'star', 'hisat2'],
                'dup_marker_tool': ['bamblaster', 'picard'],
                'base_recalibrator_tool': ['bqsr'],
                'indel_realign_tool': ['abra2'],
                'som_var_caller': ['mutect2', 'strelka2', 'varscan2', 'abra2'],
                'germ_var_caller': ['deepvariant', 'haplotypecaller'],
                'fusion_tool': ['starfusion', 'arriba', 'fusioninspector'],
                'splice_var_caller': ['snaf', 'neosplice', 'spladder'],
                'hla_typer': ['optitype', 'arcashla', 'hla-hd', 'seq2hla', 'hlapollo', 'hlaprofiler'],
                'mhc_caller_tool': ['seq2hla_ase', 'optitype_rna', 'optitype_dna'],
                'antigen_tool': ['netmhcpan', 'netmhcstabpan', 'mhcflurry', 'hlapollo', 'pepsickle'],
                'rna_quant_tool': ['salmon', 'kallisto'],
                'tx_quant_tool': ['salmon', 'kallisto'],
                'viral_detect_tool': ['virdetect'],
                'tumor_purities_tool': ['sequenza_r', 'sequenza_utils'],
                'purity_tool': ['sequenza_r', 'sequenza_utils'],
                'cna_tool': ['cnvkit'],
                'phasing_tool': ['whatshap'],
                'var_phaser_tool': ['whatshap'],
                'vcf_merge_tool': ['jacquard'],
                'vcf_merging_tool': ['jacquard']
            };
            
            // Check if tool is in the option map
            const hasAvailableOptions = toolOptionMap.hasOwnProperty(toolName);
            
            // If default is empty but tool has available options, show them
            if ((!defaultValue || defaultValue.trim() === '') && hasAvailableOptions) {
                // Return the available options, but none will be checked by default
                const tools = toolOptionMap[toolName];
                return tools
                    .filter(tool => tool !== '')
                    .map(tool => ({
                        value: tool,
                        label: getToolLabel(tool)
                    }));
            }
            
            // If default is empty and no available options, return empty (show "skipping" message)
            if (!defaultValue || defaultValue.trim() === '') {
                return [];
            }
            
            const tools = toolOptionMap[toolName] || defaultValue.split(',').map(t => t.trim());
            
            return tools
                .filter(tool => tool !== '')  // Remove empty/skip options
                .map(tool => ({
                    value: tool,
                    label: getToolLabel(tool)
                }));
        }
        
        function getToolLabel(toolValue) {
            // Custom label mappings for specific tool variants and proper capitalizations
            const customLabels = {
                'optitype_rna': 'OptiType',
                'optitype_dna': 'OptiType',
                'optitype': 'OptiType',
                'seq2hla_ase': 'seq2HLA',
                'seq2hla': 'seq2HLA',
                'jacquard_merge': 'Jacquard',
                'jacquard': 'Jacquard',
                'bwa': 'BWA',
                'bwa-mem2': 'BWA-MEM2',
                'bwamem2': 'BWA-MEM2',
                'star': 'STAR',
                'starfusion': 'STAR-Fusion',
                'star-fusion': 'STAR-Fusion',
                'gatk4': 'GATK4',
                'gatk': 'GATK',
                'fastp': 'fastp',
                'hisat2': 'HISAT2',
                'bbmap': 'BBMap',
                'minimap2': 'Minimap2',
                'bowtie2': 'Bowtie2',
                'samtools': 'SAMtools',
                'bcftools': 'BCFtools',
                'bedtools': 'BEDTools',
                'trimmomatic': 'Trimmomatic',
                'cutadapt': 'Cutadapt',
                'picard': 'Picard',
                'samblaster': 'Samblaster',
                'bamblaster': 'Samblaster',
                'deepvariant': 'DeepVariant',
                'deepsomatic': 'DeepSomatic',
                'haplotypecaller': 'HaplotypeCaller',
                'mutect2': 'Mutect2',
                'strelka2': 'Strelka2',
                'varscan2': 'VarScan2',
                'abra2': 'ABRA2',
                'abra2_rna': 'ABRA2',
                'lofreq': 'LoFreq',
                'salmon': 'Salmon',
                'kallisto': 'Kallisto',
                'arriba': 'Arriba',
                'fusioninspector': 'FusionInspector',
                'snaf': 'SNAF',
                'neosplice': 'NeoSplice',
                'spladder': 'SplAdder',
                'arcashla': 'arcasHLA',
                'arcas-hla': 'arcasHLA',
                'hla-hd': 'HLA-HD',
                'hlapollo': 'HLApollo',
                'hlaprofiler': 'HLAprofiler',
                'netmhcpan': 'NetMHCpan',
                'netmhcstabpan': 'NetMHCstabpan',
                'mhcflurry': 'MHCflurry',
                'pepsickle': 'Pepsickle',
                'virdetect': 'VirDetect',
                'sequenza': 'Sequenza',
                'sequenza_r': 'Sequenza R',
                'sequenza_utils': 'Sequenza Utils',
                'cnvkit': 'CNVkit',
                'whatshap': 'WhatsHap',
                'lohhla': 'LOHHLA',
                'bqsr': 'BQSR'
            };
            
            if (customLabels[toolValue]) {
                return customLabels[toolValue];
            }
            
            // Default: capitalize each word
            return toolValue.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('-');
        }

        function renderWorkflowConfiguration(config) {
            const container = document.getElementById('configSections');
            container.innerHTML = '';

            config.sections.forEach(section => {
                const sectionDiv = createSection(section);
                container.appendChild(sectionDiv);
            });
            
            // Initialize combine strategy visibility (default is union)
            setTimeout(() => updateCombineStrategySteps('union'), 100);
        }

        function createSection(section) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'border border-gray-200 rounded-lg overflow-hidden';

            const header = document.createElement('div');
            header.className = 'bg-indigo-600 text-white px-4 py-3 cursor-pointer flex justify-between items-center accordion-header font-semibold';
            header.innerHTML = `
                <h3 class="text-lg font-semibold">${section.displayName}</h3>
                <svg class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            `;

            const content = document.createElement('div');
            content.className = 'accordion-content bg-white';

            const innerContent = document.createElement('div');
            innerContent.className = 'p-4 space-y-4';

            section.subsections.forEach(subsection => {
                const subsectionDiv = createSubsection(subsection);
                innerContent.appendChild(subsectionDiv);
            });

            content.appendChild(innerContent);
            sectionDiv.appendChild(header);
            sectionDiv.appendChild(content);

            header.addEventListener('click', () => {
                content.classList.toggle('active');
                header.querySelector('svg').classList.toggle('rotate-180');
            });

            return sectionDiv;
        }

        function createSubsection(subsection) {
            const subsectionDiv = document.createElement('div');
            subsectionDiv.className = 'border-2 border-gray-600 rounded-lg overflow-hidden';
            
            // Create unique ID for this subsection
            const subsectionId = `subsection-${subsection.name.replace(/[^a-z0-9]/gi, '-')}`;
            subsectionDiv.dataset.subsectionId = subsectionId;

            const header = document.createElement('div');
            header.className = 'bg-gray-200 px-4 py-2 cursor-pointer flex justify-between items-center accordion-header';
            
            // Create header content with status indicator (except for References)
            const headerContent = document.createElement('div');
            headerContent.className = 'flex items-center gap-2';
            
            // Title
            const title = document.createElement('h4');
            title.className = 'text-md font-semibold';
            title.textContent = subsection.displayName;
            headerContent.appendChild(title);
            
            // Status indicator (skip for References section) - placed AFTER title
            if (subsection.name !== 'references') {
                const statusIndicator = document.createElement('span');
                statusIndicator.className = 'status-indicator';
                statusIndicator.dataset.subsectionId = subsectionId;
                statusIndicator.innerHTML = `
                    <svg class="w-5 h-5 transition-colors" fill="currentColor" viewBox="0 0 20 20">
                        <circle cx="10" cy="10" r="9" class="status-circle text-yellow-500"/>
                        <text x="10" y="14" font-size="12" font-weight="bold" text-anchor="middle" fill="white" class="status-icon">?</text>
                    </svg>
                `;
                headerContent.appendChild(statusIndicator);
            }
            
            // Arrow
            const arrow = document.createElement('svg');
            arrow.className = 'w-4 h-4 transform transition-transform';
            arrow.setAttribute('fill', 'none');
            arrow.setAttribute('stroke', 'currentColor');
            arrow.setAttribute('viewBox', '0 0 24 24');
            arrow.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>';
            
            header.appendChild(headerContent);
            header.appendChild(arrow);

            const content = document.createElement('div');
            content.className = 'accordion-content bg-white';

            const innerContent = document.createElement('div');
            innerContent.className = 'p-4 space-y-4';
            
            // Add subsection-level workflow parameters if any exist
            if (subsection.workflowParams && subsection.workflowParams.length > 0) {
                const isReferences = subsection.name === 'references';
                const paramsSection = createWorkflowParamsSection(subsection.workflowParams, isReferences);
                innerContent.appendChild(paramsSection);
            }

            subsection.steps.forEach((step, index) => {
                const stepDiv = createStep(step, index);
                innerContent.appendChild(stepDiv);
            });

            content.appendChild(innerContent);
            subsectionDiv.appendChild(header);
            subsectionDiv.appendChild(content);

            header.addEventListener('click', () => {
                const wasActive = content.classList.contains('active');
                content.classList.toggle('active');
                arrow.classList.toggle('rotate-180');
                
                // If collapsing (was active, now inactive), mark as visited
                if (wasActive) {
                    markSubsectionVisited(subsectionId);
                }
            });

            return subsectionDiv;
        }

        function createStep(step, index = 0) {
            const stepDiv = document.createElement('div');
            // Single dark gray background for all steps
            stepDiv.className = 'space-y-3 p-3 rounded bg-gray-100';
            
            // Add data attributes for conditional visibility
            if (step.name === 'som_vars_to_isecd_som_vars') {
                stepDiv.dataset.combineStrategy = 'intersection';
            } else if (step.name === 'som_vars_to_union_som_vars') {
                stepDiv.dataset.combineStrategy = 'union';
            }

            const stepHeader = document.createElement('div');
            stepHeader.className = 'font-medium text-gray-800 mb-2 flex items-center gap-2';
            
            const stepTitle = document.createElement('span');
            stepTitle.textContent = step.displayName;
            stepHeader.appendChild(stepTitle);
            
            // Add tooltips for specific steps
            const stepTooltips = {
                'som_vars_to_hi_conf_som_vars': 'For generating MAF files, NOT for being passed through to neoantigen detection',
                'make_phased_tumor_vars': 'Tumor variants include both somatic and germline variants for the purpose of incorporating germline variants during peptide generation',
                'alns_to_tumor_purities': 'Only lists tools that actually use a transcript quantifier (e.g., TidyEstimate, estimate)'
            };
            
            if (stepTooltips[step.name]) {
                const tooltipSpan = document.createElement('span');
                tooltipSpan.className = 'tooltip';
                tooltipSpan.innerHTML = `
                    <svg class="w-4 h-4 text-gray-400 inline cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span class="tooltiptext">${stepTooltips[step.name]}</span>
                `;
                stepHeader.appendChild(tooltipSpan);
            }
            
            stepDiv.appendChild(stepHeader);
            
            // Add workflow parameters section if any exist
            if (step.workflowParams && step.workflowParams.length > 0) {
                const paramsSection = createWorkflowParamsSection(step.workflowParams);
                stepDiv.appendChild(paramsSection);
            }

            step.tools.forEach(tool => {
                const toolDiv = createToolSelector(tool);
                stepDiv.appendChild(toolDiv);
            });

            return stepDiv;
        }
        
        function createWorkflowParamsSection(workflowParams, isReferences = false) {
            const section = document.createElement('div');
            
            if (isReferences) {
                // References section styling
                section.className = 'bg-slate-50 border border-slate-300 rounded-md p-3 mb-3';
            } else {
                // Regular workflow parameters styling
                section.className = 'bg-amber-50 border border-amber-300 rounded-md p-3 mb-3';
            }
            
            const header = document.createElement('div');
            header.className = 'flex items-center gap-2 mb-2';
            
            const title = document.createElement('span');
            if (isReferences) {
                title.className = 'font-medium text-sm text-slate-900';
                title.textContent = 'Reference Files';
            } else {
                title.className = 'font-medium text-sm text-amber-900';
                title.textContent = 'Workflow Parameters';
            }
            header.appendChild(title);
            
            const tooltip = document.createElement('span');
            tooltip.className = 'tooltip';
            if (isReferences) {
                tooltip.innerHTML = `
                    <svg class="w-4 h-4 text-slate-700 inline cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span class="tooltiptext">Changes made here will be inherited by downstream workflows. To change specific references for individual workflows, modify them in that workflow's section.</span>
                `;
            } else {
                tooltip.innerHTML = `
                    <svg class="w-4 h-4 text-amber-700 inline cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span class="tooltiptext">These parameters will likely apply to multiple tools</span>
                `;
            }
            header.appendChild(tooltip);
            section.appendChild(header);
            
            const paramsContainer = document.createElement('div');
            paramsContainer.className = 'space-y-2';
            
            workflowParams.forEach(param => {
                const paramDiv = createWorkflowParam(param);
                paramsContainer.appendChild(paramDiv);
            });
            
            section.appendChild(paramsContainer);
            return section;
        }
        
        function createWorkflowParam(param) {
            const paramDiv = document.createElement('div');
            paramDiv.className = 'flex items-center gap-2';
            
            const label = document.createElement('label');
            label.className = 'text-sm font-medium text-gray-700 min-w-[150px]';
            label.textContent = humanReadableName(param.name) + ':';
            label.htmlFor = param.parameter.replace(/\./g, '-').replace(/\$/g, '-');
            
            paramDiv.appendChild(label);
            
            // Create input wrapper with fixed space for warning icon
            const inputWrapper = document.createElement('div');
            inputWrapper.className = 'flex items-center gap-1 flex-1';
            
            // Create appropriate input based on parameter type
            if (param.name === 'combine_strategy') {
                const select = document.createElement('select');
                select.className = 'border border-gray-300 rounded px-2 py-1 text-sm flex-1 workflow-param';
                select.id = param.parameter.replace(/\./g, '-').replace(/\$/g, '-');
                select.dataset.parameter = param.parameter;
                
                ['union', 'intersection'].forEach(option => {
                    const opt = document.createElement('option');
                    opt.value = option;
                    opt.textContent = option.charAt(0).toUpperCase() + option.slice(1);
                    if (param.value === option) opt.selected = true;
                    select.appendChild(opt);
                });
                
                // Add change listener to toggle visibility of union/intersection steps
                select.addEventListener('change', () => {
                    updateCombineStrategySteps(select.value);
                });
                
                inputWrapper.appendChild(select);
                
                const tooltip = document.createElement('span');
                tooltip.className = 'tooltip';
                tooltip.innerHTML = `
                    <svg class="w-4 h-4 text-gray-400 inline cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span class="tooltiptext">Determines how to combine variants from the various somatic variant callers</span>
                `;
                inputWrapper.appendChild(tooltip);
            } else if (param.name === 'peptide_lengths') {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'border border-gray-300 rounded px-2 py-1 text-sm flex-1 workflow-param';
                input.id = param.parameter.replace(/\./g, '-').replace(/\$/g, '-');
                input.dataset.parameter = param.parameter;
                input.value = param.value;
                input.placeholder = 'e.g., 8,9,10,11';
                
                inputWrapper.appendChild(input);
            } else {
                // Default text input
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'border border-gray-300 rounded px-2 py-1 text-sm flex-1 workflow-param';
                input.id = param.parameter.replace(/\./g, '-').replace(/\$/g, '-');
                input.dataset.parameter = param.parameter;
                input.value = param.value;
                
                // Add placeholder for reference parameters
                if (param.isReference) {
                    input.placeholder = 'Path to reference file';
                    input.dataset.originalValue = param.value;
                    
                    // Create fixed warning icon placeholder
                    const warningPlaceholder = document.createElement('span');
                    warningPlaceholder.className = 'w-6 h-6 flex items-center justify-center';
                    
                    // Add input listener to show warning in real-time
                    input.addEventListener('input', (e) => {
                        if (e.target.value !== e.target.dataset.originalValue) {
                            warningPlaceholder.innerHTML = `
                                <span class="tooltip">
                                    <span class="text-amber-600 text-lg"></span>
                                    <span class="tooltiptext">Ensure you download this reference and store it in your RAFT references directory</span>
                                </span>
                            `;
                        } else {
                            warningPlaceholder.innerHTML = '';
                        }
                    });
                    
                    inputWrapper.appendChild(input);
                    inputWrapper.appendChild(warningPlaceholder);
                } else {
                    inputWrapper.appendChild(input);
                }
                
                // Add description tooltip if available
                if (param.description) {
                    const tooltip = document.createElement('span');
                    tooltip.className = 'tooltip';
                    tooltip.innerHTML = `
                        <svg class="w-4 h-4 text-gray-400 inline cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <span class="tooltiptext">${param.description}</span>
                    `;
                    inputWrapper.appendChild(tooltip);
                }
            }
            
            paramDiv.appendChild(inputWrapper);
            return paramDiv;
        }
        
        function updateCombineStrategySteps(strategy) {
            // Hide/show union and intersection steps based on selected strategy
            document.querySelectorAll('[data-combine-strategy]').forEach(stepDiv => {
                const stepStrategy = stepDiv.dataset.combineStrategy;
                if (stepStrategy === strategy) {
                    stepDiv.style.display = '';
                } else {
                    stepDiv.style.display = 'none';
                }
            });
        }

        function createToolSelector(tool) {
            const toolDiv = document.createElement('div');
            toolDiv.className = 'bg-gray-50 p-3 rounded-md space-y-2';

            const labelDiv = document.createElement('div');
            labelDiv.className = 'flex items-center gap-2 mb-2';
            
            const label = document.createElement('span');
            label.className = 'font-medium text-sm';
            label.textContent = tool.displayName;
            
            const tooltip = document.createElement('span');
            tooltip.className = 'tooltip';
            tooltip.innerHTML = `
                <svg class="w-4 h-4 text-gray-400 cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <span class="tooltiptext">Parameter: ${tool.parameter}</span>
            `;
            
            labelDiv.appendChild(label);
            
            // Add "no tools selected" warning next to the label if default is empty but options are available
            // This means tools are available but none selected by default (skipping the subworkflow)
            if (tool.default === '' && tool.options.length > 0) {
                const noToolsSpan = document.createElement('span');
                noToolsSpan.className = 'text-xs text-gray-600 ml-2 inline-flex items-center gap-1';
                noToolsSpan.innerHTML = `
                    <svg class="w-3 h-3 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span class="italic">No tool(s) currently selected, so skipping subworkflow</span>
                `;
                labelDiv.appendChild(noToolsSpan);
            }
            
            labelDiv.appendChild(tooltip);
            toolDiv.appendChild(labelDiv);

            // Add warning div (hidden by default for single-use tools)
            if (tool.warning) {
                const warningDiv = document.createElement('div');
                warningDiv.className = 'text-xs text-amber-600 bg-amber-50 p-2 rounded border border-amber-200 mb-2 hidden';
                warningDiv.id = `warning-${tool.parameter.replace(/\./g, '-').replace(/\$/g, '-')}`;
                warningDiv.textContent = tool.warning;
                toolDiv.appendChild(warningDiv);
            }
            
            // If no options, return early (no checkboxes to render)
            if (tool.options.length === 0) {
                return toolDiv;
            }

            tool.options.forEach((option, index) => {
                const optionDiv = createToolOption(tool, option, index);
                toolDiv.appendChild(optionDiv);
            });

            return toolDiv;
        }

        function createToolOption(tool, option, index) {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'flex items-start gap-2 mb-2';

            const checkboxId = `${tool.parameter}_${option.value}`;
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.name = tool.parameter;
            checkbox.id = checkboxId;
            checkbox.className = 'tool-checkbox mt-1';
            checkbox.value = option.value;
            
            const defaultValues = tool.default.split(',').map(v => v.trim());
            if (defaultValues.includes(option.value)) {
                checkbox.checked = true;
            }

            const contentDiv = document.createElement('div');
            contentDiv.className = 'flex-1 tool-options';

            const optionLabel = document.createElement('label');
            optionLabel.htmlFor = checkboxId;
            optionLabel.className = 'font-medium text-sm cursor-pointer';
            optionLabel.textContent = option.label;
            
            // Add explanatory tooltip for bamblaster
            if (option.value === 'bamblaster') {
                const bamblasterTooltip = document.createElement('span');
                bamblasterTooltip.className = 'tooltip ml-1';
                bamblasterTooltip.innerHTML = `
                    <svg class="w-3 h-3 text-gray-400 inline cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span class="tooltiptext">Within the workflow, this tool is referred to as "Bamblaster" due to a wrapper script making Samblaster BAM-compatible.</span>
                `;
                optionLabel.appendChild(bamblasterTooltip);
            }
            
            // Add note for NetMHCpan and NetMHCstabpan about Docker images
            if (option.value === 'netmhcpan' || option.value === 'netmhcstabpan') {
                const netmhcNote = document.createElement('a');
                netmhcNote.href = 'https://uselens.io/en/lens-v1.8/technical.html#creating-netmhc-docker-images';
                netmhcNote.target = '_blank';
                netmhcNote.className = 'ml-2 text-xs text-blue-600 hover:text-blue-800 inline-flex items-center gap-1';
                netmhcNote.innerHTML = `
                    <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span>Docker image instructions</span>
                `;
                optionLabel.appendChild(netmhcNote);
            }

            if (tool.singleUse && index > 0 && defaultValues.includes(option.value)) {
                // Only add secondary styling initially if this is not the first default value
                // The actual secondary styling will be updated dynamically based on selections
            }

            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'mt-1 space-y-1';

            // Normalize tool names for container lookups
            let containerLookupName = option.value;
            if (option.value === 'bamblaster') containerLookupName = 'samblaster';
            if (option.value === 'bqsr') containerLookupName = 'gatk4';
            if (option.value === 'haplotypecaller') containerLookupName = 'gatk4';
            if (option.value === 'optitype_rna') containerLookupName = 'optitype';
            if (option.value === 'optitype_dna') containerLookupName = 'optitype';
            if (option.value === 'seq2hla_ase') containerLookupName = 'seq2hla';
            
            // Check if tool has container versions (BioContainers or DockerHub)
            const cachedData = biocontainersCache[containerLookupName];
            const hasVersions = cachedData && cachedData.versions && cachedData.versions.length > 0;
            
            // Use cached versions or fallback to mock
            const versions = hasVersions ? cachedData.versions : (mockBiocontainerVersions[containerLookupName] || null);
            const isOfficial = cachedData?.isOfficial !== false; // True for BioContainers, false for DockerHub
            const dockerAccount = cachedData?.account;
            const dockerRepo = cachedData?.repo;

            if (versions) {
                // Add "Version" label
                const versionLabel = document.createElement('div');
                versionLabel.className = 'text-xs text-gray-600 font-medium';
                versionLabel.textContent = 'Version';
                optionsContainer.appendChild(versionLabel);
                
                // Version dropdown (BioContainers or DockerHub)
                const versionWrapper = document.createElement('div');
                versionWrapper.className = 'flex items-center gap-1';
                
                const versionSelectElem = document.createElement('select');
                versionSelectElem.className = 'border border-gray-300 rounded px-2 py-1 text-sm flex-1';
                versionSelectElem.dataset.toolName = option.value;
                versionSelectElem.dataset.isOfficial = isOfficial;
                if (dockerAccount) versionSelectElem.dataset.dockerAccount = dockerAccount;
                if (dockerRepo) versionSelectElem.dataset.dockerRepo = dockerRepo;
                
                const recommendedVersion = recommendedToolVersions[containerLookupName];
                
                versions.forEach(version => {
                    const versionOption = document.createElement('option');
                    versionOption.value = version;
                    // Add warning symbol AFTER version for non-BioContainers (DockerHub) images
                    versionOption.textContent = isOfficial ? version : `${version} `;
                    
                    // Add title tooltip for non-official versions
                    if (!isOfficial) {
                        versionOption.title = `Not an official BioContainers image! Using DockerHub image: ${dockerAccount}/${dockerRepo}`;
                    }
                    
                    // Select recommended version if available, otherwise first version
                    if (recommendedVersion && version === recommendedVersion) {
                        versionOption.selected = true;
                    } else if (!recommendedVersion && version === versions[0]) {
                        versionOption.selected = true;
                    }
                    
                    versionSelectElem.appendChild(versionOption);
                });

                versionWrapper.appendChild(versionSelectElem);
                
                // Add warning icon for non-official (DockerHub) images
                if (!isOfficial) {
                    const warningSpan = document.createElement('span');
                    warningSpan.className = 'tooltip';
                    warningSpan.innerHTML = `
                        <svg class="w-5 h-5 text-yellow-500 cursor-help" fill="currentColor" viewBox="0 0 20 20">
                            <circle cx="10" cy="10" r="9" fill="currentColor"/>
                            <text x="10" y="14" font-size="12" font-weight="bold" text-anchor="middle" fill="white">!</text>
                        </svg>
                        <span class="tooltiptext">Not an official BioContainers image! Using DockerHub image: ${dockerAccount}/${dockerRepo}</span>
                    `;
                    versionWrapper.appendChild(warningSpan);
                }
                
                optionsContainer.appendChild(versionWrapper);
            } else {
                // Add "Version" label for custom container
                const versionLabel = document.createElement('div');
                versionLabel.className = 'text-xs text-gray-600 font-medium';
                versionLabel.textContent = 'Version';
                optionsContainer.appendChild(versionLabel);
                
                // Custom container input for tools without any container registry entry
                const containerInput = document.createElement('input');
                containerInput.type = 'text';
                containerInput.className = 'border border-gray-300 rounded px-2 py-1 text-sm flex-1 font-mono';
                containerInput.placeholder = 'Docker URI or Singularity path (e.g., docker://user/image:tag or /path/to/image.sif)';
                containerInput.dataset.toolName = option.value;
                containerInput.dataset.isCustomContainer = 'true';
                
                // Add info icon with tooltip
                const infoSpan = document.createElement('span');
                infoSpan.className = 'tooltip';
                infoSpan.innerHTML = `
                    <svg class="w-4 h-4 text-blue-500 cursor-help mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span class="tooltiptext">This tool is not available in BioContainers or DockerHub. Please provide your own container URI or Singularity path.</span>
                `;
                
                const containerWrapper = document.createElement('div');
                containerWrapper.className = 'flex gap-1';
                containerWrapper.appendChild(containerInput);
                containerWrapper.appendChild(infoSpan);
                
                optionsContainer.appendChild(containerWrapper);
            }

            // Add "Parameters" label
            const paramsLabel = document.createElement('div');
            paramsLabel.className = 'text-xs text-gray-600 font-medium mt-2';
            paramsLabel.textContent = 'Parameters';
            optionsContainer.appendChild(paramsLabel);
            
            const paramsInput = document.createElement('input');
            paramsInput.type = 'text';
            paramsInput.className = 'border border-gray-300 rounded px-2 py-1 text-sm flex-1 font-mono';
            paramsInput.placeholder = 'Tool parameters (e.g., min_af:0.05)';
            
            if (typeof tool.defaultParams === 'object') {
                paramsInput.value = tool.defaultParams[option.value] || '';
            } else {
                paramsInput.value = '';
            }

            optionsContainer.appendChild(paramsInput);
            
            // Add tool-specific reference input if this tool has refs
            if (tool.toolRefs && tool.toolRefs[option.value]) {
                // Add "Reference File" label
                const refLabel = document.createElement('div');
                refLabel.className = 'text-xs text-gray-600 font-medium mt-2';
                refLabel.textContent = 'Reference File';
                optionsContainer.appendChild(refLabel);
                
                // Create wrapper for input and warning icon
                const refWrapper = document.createElement('div');
                refWrapper.className = 'flex items-center gap-1';
                
                const refInput = document.createElement('input');
                refInput.type = 'text';
                refInput.className = 'border border-gray-300 rounded px-2 py-1 text-sm flex-1 font-mono';
                refInput.placeholder = 'Tool reference';
                refInput.value = tool.toolRefs[option.value];
                refInput.dataset.toolName = option.value;
                refInput.dataset.isToolRef = 'true';
                refInput.dataset.originalValue = tool.toolRefs[option.value];
                
                // Create fixed warning icon placeholder
                const warningPlaceholder = document.createElement('span');
                warningPlaceholder.className = 'w-6 h-6 flex items-center justify-center';
                
                // Add input listener to show warning
                refInput.addEventListener('input', (e) => {
                    if (e.target.value !== e.target.dataset.originalValue) {
                        warningPlaceholder.innerHTML = `
                            <span class="tooltip">
                                <span class="text-amber-600 text-lg"></span>
                                <span class="tooltiptext">Ensure you download this reference and store it in your RAFT references directory</span>
                            </span>
                        `;
                    } else {
                        warningPlaceholder.innerHTML = '';
                    }
                });
                
                refWrapper.appendChild(refInput);
                refWrapper.appendChild(warningPlaceholder);
                optionsContainer.appendChild(refWrapper);
            }

            contentDiv.appendChild(optionLabel);
            contentDiv.appendChild(optionsContainer);

            optionDiv.appendChild(checkbox);
            optionDiv.appendChild(contentDiv);

            checkbox.addEventListener('change', () => {
                updateToolSelection(tool, checkbox);
                generateConfigOutput();
                generateMethodsDescription();
            });

            // Add change listener for version select or container input
            const versionSelectElem = optionsContainer.querySelector('select');
            const containerInputElem = optionsContainer.querySelector('input[data-is-custom-container="true"]');
            
            if (versionSelectElem) {
                versionSelectElem.addEventListener('change', () => {
                    generateConfigOutput();
                generateMethodsDescription();
                });
            } else if (containerInputElem) {
                containerInputElem.addEventListener('input', () => {
                    generateConfigOutput();
                generateMethodsDescription();
                });
            }

            paramsInput.addEventListener('input', () => {
                generateConfigOutput();
                generateMethodsDescription();
            });
            
            // Set initial styling if this is checked by default
            if (checkbox.checked && tool.singleUse) {
                // Use setTimeout to ensure DOM is ready
                setTimeout(() => updateToolSelection(tool, checkbox), 0);
            }

            return optionDiv;
        }

        function updateToolSelection(tool, checkbox) {
            if (tool.singleUse) {
                const checkedBoxes = Array.from(document.querySelectorAll(`input[name="${tool.parameter}"]:checked`));
                
                // Show/hide warning based on number of selections
                const warningId = `warning-${tool.parameter.replace(/\./g, '-').replace(/\$/g, '-')}`;
                const warningDiv = document.getElementById(warningId);
                
                if (warningDiv) {
                    if (checkedBoxes.length > 1) {
                        warningDiv.classList.remove('hidden');
                    } else {
                        warningDiv.classList.add('hidden');
                    }
                }
                
                // Update styling for secondary tools
                checkedBoxes.forEach((box, index) => {
                    const label = document.querySelector(`label[for="${box.id}"]`);
                    
                    // Remove any existing secondary tooltip
                    const existingTooltip = label.querySelector('.tooltip');
                    if (existingTooltip) {
                        existingTooltip.remove();
                    }
                    
                    if (index > 0 && checkedBoxes.length > 1) {
                        // This is a secondary selection
                        if (!label.classList.contains('secondary-tool')) {
                            label.classList.add('secondary-tool');
                        }
                        
                        // Add tooltip
                        const secondaryTooltip = document.createElement('span');
                        secondaryTooltip.className = 'tooltip ml-1';
                        secondaryTooltip.innerHTML = `
                            <svg class="w-3 h-3 text-amber-500 inline cursor-help" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span class="tooltiptext">This tool will run but only the first selected tool will be used for downstream analysis</span>
                        `;
                        label.appendChild(secondaryTooltip);
                    } else {
                        // This is the primary (or only) selection
                        label.classList.remove('secondary-tool');
                    }
                });
            }
        }
        
        function markSubsectionVisited(subsectionId) {
            // Add to visited set
            visitedSubsections.add(subsectionId);
            
            // Update the status indicator
            const indicator = document.querySelector(`.status-indicator[data-subsection-id="${subsectionId}"]`);
            if (indicator) {
                const circle = indicator.querySelector('.status-circle');
                const icon = indicator.querySelector('.status-icon');
                
                // Change from yellow ? to green 
                circle.classList.remove('text-yellow-500');
                circle.classList.add('text-green-500');
                icon.textContent = '';
            }
        }

        function generateMethodsDescription() {
            const methods = [];
            
            methods.push('METHODS');
            methods.push('=======');
            methods.push('');
            methods.push(`Workflow: ${state.workflow}`);
            methods.push(`Species: ${state.species}`);
            methods.push(`Starting Data: ${state.startingData}`);
            methods.push(`LENS Version: ${state.version}`);
            methods.push('');
            
            // Collect all tool information
            const toolData = {};
            document.querySelectorAll('.tool-checkbox:checked').forEach(checkbox => {
                const parameter = checkbox.name;
                const toolValue = checkbox.value;
                const optionDiv = checkbox.closest('.flex.items-start');
                
                const versionSelect = optionDiv.querySelector('select');
                const customContainer = optionDiv.querySelector('input[data-is-custom-container="true"]');
                const paramsInput = optionDiv.querySelector('input[type="text"]:not([data-is-custom-container]):not([data-is-tool-ref])');
                const refInput = optionDiv.querySelector('input[data-is-tool-ref="true"]');
                
                let version = customContainer?.value || versionSelect?.value || 'latest';
                let params = paramsInput?.value?.trim() || '';
                let ref = refInput?.value?.trim() || '';
                
                // Parse parameter path to get section info
                const parts = parameter.replace('params.', '').split('$');
                const section = parts[1] || parts[0];
                
                if (!toolData[section]) toolData[section] = [];
                
                toolData[section].push({
                    name: toolValue,
                    displayName: getToolLabel(toolValue),
                    version: version,
                    params: params,
                    ref: ref
                });
            });
            
            // Generate methods text by section
            const sectionOrder = ['qc', 'alignment', 'rna_quant', 'somatic', 'germline', 'seq_variation', 
                                 'immuno', 'fusion', 'splice', 'viral', 'tumor_purity', 'copy_number_alterations', 
                                 'hla_loh', 'neos', 'pmhc_characterization'];
            
            for (const sectionKey of sectionOrder) {
                if (!toolData[sectionKey] || toolData[sectionKey].length === 0) continue;
                
                const sectionName = humanReadableName(sectionKey);
                methods.push(`${sectionName}:`);
                
                toolData[sectionKey].forEach(tool => {
                    let toolLine = `  - ${tool.displayName} (v${tool.version})`;
                    if (tool.params) toolLine += ` with parameters: ${tool.params}`;
                    if (tool.ref) toolLine += ` using reference: ${tool.ref}`;
                    methods.push(toolLine);
                });
                
                methods.push('');
            }
            
            // Add reference files section
            const refFiles = {};
            document.querySelectorAll('.workflow-param').forEach(input => {
                if (input.placeholder && input.placeholder.includes('reference')) {
                    const label = input.closest('.flex').querySelector('label')?.textContent?.replace(':', '') || 
                                 humanReadableName(input.dataset.parameter.split('.').pop().split('$').pop());
                    if (input.value) {
                        refFiles[label] = input.value;
                    }
                }
            });
            
            if (Object.keys(refFiles).length > 0) {
                methods.push('Reference Files:');
                for (const [name, path] of Object.entries(refFiles)) {
                    methods.push(`  - ${name}: ${path}`);
                }
                methods.push('');
            }
            
            // Add workflow parameters
            const workflowParams = {};
            document.querySelectorAll('.workflow-param').forEach(input => {
                if (!input.placeholder || !input.placeholder.includes('reference')) {
                    const paramName = input.dataset.parameter.split('.').pop().split('$').pop();
                    const displayName = humanReadableName(paramName);
                    if (input.value && !workflowParams[displayName]) {
                        workflowParams[displayName] = input.value;
                    }
                }
            });
            
            if (Object.keys(workflowParams).length > 0) {
                methods.push('Workflow Parameters:');
                for (const [name, value] of Object.entries(workflowParams)) {
                    methods.push(`  - ${name}: ${value}`);
                }
                methods.push('');
            }
            
            methods.push('---');
            methods.push(`Generated: ${new Date().toLocaleString()}`);
            
            document.getElementById('methodsOutput').value = methods.join('\n');
        }

        function generateMethodsDescription() {
            const methods = [];
            
            methods.push('METHODS');
            methods.push('');
            
            // Collect all tools and their versions
            const toolsUsed = {};
            document.querySelectorAll('.tool-checkbox:checked').forEach(checkbox => {
                const toolValue = checkbox.value;
                const optionDiv = checkbox.closest('.flex.items-start');
                
                const versionSelect = optionDiv.querySelector('select');
                const containerInput = optionDiv.querySelector('input[data-is-custom-container="true"]');
                const paramsInput = optionDiv.querySelector('input[type="text"]:not([data-is-custom-container])');
                
                let version = 'latest';
                if (containerInput && containerInput.value) {
                    version = containerInput.value;
                } else if (versionSelect) {
                    version = versionSelect.value;
                }
                
                // Clean version string - extract base version number
                version = cleanVersionString(version);
                
                const params = paramsInput ? paramsInput.value.trim() : '';
                
                if (!toolsUsed[toolValue]) {
                    toolsUsed[toolValue] = { version, params: [] };
                }
                if (params) {
                    toolsUsed[toolValue].params.push(params);
                }
            });
            
            // Reference files
            const references = {};
            document.querySelectorAll('.workflow-param').forEach(input => {
                const param = input.dataset.parameter;
                if (param && (param.includes('ref') || param.includes('gtf') || param.includes('bed'))) {
                    const paramName = param.split('$').pop().replace('params.', '');
                    if (input.value) {
                        references[paramName] = input.value;
                    }
                }
            });
            
            // Collect workflow parameters
            const workflowParams = {};
            document.querySelectorAll('.workflow-param').forEach(input => {
                const param = input.dataset.parameter;
                if (param && !param.includes('ref') && !param.includes('gtf') && !param.includes('bed')) {
                    const paramName = param.split('$').pop().replace('params.', '');
                    if (input.value) {
                        workflowParams[paramName] = input.value;
                    }
                }
            });
            
            // Group tools by category
            const toolCategories = {
                qc: { name: 'Quality Control', tools: ['fastqc', 'multiqc', 'fastp', 'trimmomatic', 'cutadapt'] },
                alignment: { name: 'alignment', tools: ['bwa', 'star', 'hisat2', 'minimap2', 'bowtie2'] },
                dedup: { name: 'duplicate marking', tools: ['bamblaster', 'samblaster', 'picard'] },
                bqsr: { name: 'base quality score recalibration', tools: ['bqsr', 'gatk4'] },
                realign: { name: 'indel realignment', tools: ['abra2'] },
                quant: { name: 'transcript quantification', tools: ['salmon', 'kallisto', 'rsem', 'featurecounts'] },
                somatic: { name: 'somatic variant calling', tools: ['mutect2', 'strelka2', 'varscan2', 'deepvariant', 'deepsomatic', 'somaticsniper'] },
                germline: { name: 'germline variant calling', tools: ['haplotypecaller', 'deepvariant', 'strelka2'] },
                filter: { name: 'variant filtering', tools: ['bcftools', 'gatk4'] },
                norm: { name: 'variant normalization', tools: ['bcftools', 'vt'] },
                annot: { name: 'variant annotation', tools: ['snpeff', 'vep', 'funcotator'] },
                mhc: { name: 'MHC typing', tools: ['optitype', 'seq2hla', 'arcashla', 'hla-hd'] },
                fusion: { name: 'gene fusion detection', tools: ['starfusion', 'arriba', 'fusioncatcher'] },
                splice: { name: 'splice variant analysis', tools: ['snaf', 'neosplice', 'spladder'] },
                viral: { name: 'viral detection', tools: ['virdetect', 'virusseq'] },
                purity: { name: 'tumor purity estimation', tools: ['sequenza', 'absolute', 'estimate', 'tidyestimate'] },
                cnv: { name: 'copy number analysis', tools: ['cnvkit', 'sequenza', 'gatk4'] },
                loh: { name: 'HLA loss of heterozygosity analysis', tools: ['lohhla'] },
                neoantigen: { name: 'neoantigen prediction', tools: ['netmhcpan', 'netmhcstabpan', 'mhcflurry', 'mhcnuggets'] },
                phasing: { name: 'variant phasing', tools: ['whatshap', 'hapcut2'] }
            };
            
            // Categorize used tools
            const categorizedTools = {};
            for (const [catKey, catData] of Object.entries(toolCategories)) {
                for (const tool of Object.keys(toolsUsed)) {
                    if (catData.tools.includes(tool.toLowerCase())) {
                        if (!categorizedTools[catKey]) categorizedTools[catKey] = { name: catData.name, tools: [] };
                        categorizedTools[catKey].tools.push({ tool, ...toolsUsed[tool] });
                    }
                }
            }
            
            // Build continuous paragraphs
            const paragraphs = [];
            
            // First paragraph - pipeline overview and alignment
            let para1 = `Sequencing data processing and analysis were performed using the ${state.workflow || 'LENS'} workflow (version ${state.version || '1.8'})`;
            
            if (references.aln_ref || references.global_aln_ref) {
                const refName = (references.aln_ref || references.global_aln_ref).replace(/\.(fa|fasta)$/, '');
                para1 += `. Reads were aligned to the ${refName} reference genome`;
                
                if (categorizedTools.alignment && categorizedTools.alignment.tools.length > 0) {
                    const aligners = categorizedTools.alignment.tools.map(t => formatToolVersion(t));
                    para1 += ` using ${formatList(aligners)}`;
                }
                para1 += '.';
            }
            
            if (references.gtf || references.global_gtf) {
                para1 += ` Gene annotations were obtained from ${references.gtf || references.global_gtf}.`;
            }
            
            if (references.bed || references.global_bed) {
                para1 += ` Target regions were defined using ${references.bed || references.global_bed}.`;
            }
            
            paragraphs.push(para1);
            
            // Second paragraph - QC, preprocessing
            const para2Parts = [];
            
            if (categorizedTools.qc) {
                const qcTools = categorizedTools.qc.tools.map(t => formatToolVersion(t));
                para2Parts.push(`Quality control of sequencing reads was performed using ${formatList(qcTools)}`);
            }
            
            if (categorizedTools.dedup) {
                const dedupTools = categorizedTools.dedup.tools.map(t => formatToolVersion(t));
                para2Parts.push(`duplicate reads were marked using ${formatList(dedupTools)}`);
            }
            
            if (categorizedTools.bqsr) {
                const bqsrTools = categorizedTools.bqsr.tools.map(t => formatToolVersion(t));
                let bqsrText = `base quality score recalibration was performed using ${formatList(bqsrTools)}`;
                if (references.known_sites_ref || references.global_known_sites) {
                    bqsrText += ` with known variants from ${references.known_sites_ref || references.global_known_sites}`;
                }
                para2Parts.push(bqsrText);
            }
            
            if (categorizedTools.realign) {
                const realignTools = categorizedTools.realign.tools.map(t => formatToolVersion(t));
                para2Parts.push(`indel realignment was performed using ${formatList(realignTools)}`);
            }
            
            // Join paragraph parts with commas, not periods
            if (para2Parts.length > 0) {
                let para2 = para2Parts[0].charAt(0).toUpperCase() + para2Parts[0].slice(1);
                if (para2Parts.length > 1) {
                    // Join with commas and 'and' before last item
                    if (para2Parts.length === 2) {
                        para2 += ' and ' + para2Parts[1];
                    } else {
                        para2 += ', ' + para2Parts.slice(1, -1).join(', ') + ', and ' + para2Parts[para2Parts.length - 1];
                    }
                }
                para2 += '.';
                paragraphs.push(para2);
            }
            
            // Third paragraph - transcript quantification
            if (categorizedTools.quant) {
                const quantTools = categorizedTools.quant.tools.map(t => formatToolVersion(t));
                let para3 = `Transcript abundance was quantified using ${formatList(quantTools)}.`;
                if (workflowParams.tpm_threshold) {
                    para3 += ` Transcripts were filtered at a threshold of ${workflowParams.tpm_threshold} transcripts per million (TPM).`;
                }
                paragraphs.push(para3);
            }
            
            // Fourth paragraph - variant calling
            const para4Parts = [];
            
            if (categorizedTools.somatic) {
                const somaticTools = categorizedTools.somatic.tools.map(t => formatToolVersion(t));
                let somaticText = `Somatic variants were identified using ${formatList(somaticTools)}`;
                if (workflowParams.combine_strategy) {
                    somaticText += `, and variants from multiple callers were combined using ${workflowParams.combine_strategy} strategy`;
                }
                para4Parts.push(somaticText);
            }
            
            if (categorizedTools.germline) {
                const germlineTools = categorizedTools.germline.tools.map(t => formatToolVersion(t));
                para4Parts.push(`germline variants were called using ${formatList(germlineTools)}`);
            }
            
            const varProcSteps = [];
            if (categorizedTools.filter) {
                const filterTools = categorizedTools.filter.tools.map(t => formatToolVersion(t));
                varProcSteps.push(`filtered using ${formatList(filterTools)}`);
            }
            if (categorizedTools.norm) {
                const normTools = categorizedTools.norm.tools.map(t => formatToolVersion(t));
                varProcSteps.push(`normalized using ${formatList(normTools)}`);
            }
            if (categorizedTools.annot) {
                const annotTools = categorizedTools.annot.tools.map(t => formatToolVersion(t));
                varProcSteps.push(`annotated using ${formatList(annotTools)}`);
            }
            if (varProcSteps.length > 0) {
                para4Parts.push(`variants were ${varProcSteps.join(', ')}`);
            }
            
            if (categorizedTools.phasing) {
                const phaseTools = categorizedTools.phasing.tools.map(t => formatToolVersion(t));
                para4Parts.push(`variant phasing was performed using ${formatList(phaseTools)}`);
            }
            
            if (para4Parts.length > 0) {
                let para4 = para4Parts[0].charAt(0).toUpperCase() + para4Parts[0].slice(1);
                if (para4Parts.length > 1) {
                    // Join with commas and 'and' before last item
                    if (para4Parts.length === 2) {
                        para4 += ' and ' + para4Parts[1];
                    } else {
                        para4 += ', ' + para4Parts.slice(1, -1).join(', ') + ', and ' + para4Parts[para4Parts.length - 1];
                    }
                }
                para4 += '.';
                paragraphs.push(para4);
            }
            
            // Fifth paragraph - structural variants
            const para5Parts = [];
            
            if (categorizedTools.fusion) {
                const fusionTools = categorizedTools.fusion.tools.map(t => formatToolVersion(t));
                para5Parts.push(`Gene fusions were identified using ${formatList(fusionTools)}`);
            }
            
            if (categorizedTools.splice) {
                const spliceTools = categorizedTools.splice.tools.map(t => formatToolVersion(t));
                para5Parts.push(`splice variants were detected using ${formatList(spliceTools)}`);
            }
            
            if (categorizedTools.viral) {
                const viralTools = categorizedTools.viral.tools.map(t => formatToolVersion(t));
                para5Parts.push(`viral sequences were detected using ${formatList(viralTools)}`);
            }
            
            if (para5Parts.length > 0) {
                let para5 = para5Parts[0].charAt(0).toUpperCase() + para5Parts[0].slice(1);
                if (para5Parts.length > 1) {
                    if (para5Parts.length === 2) {
                        para5 += ' and ' + para5Parts[1];
                    } else {
                        para5 += ', ' + para5Parts.slice(1, -1).join(', ') + ', and ' + para5Parts[para5Parts.length - 1];
                    }
                }
                para5 += '.';
                paragraphs.push(para5);
            }
            
            // Sixth paragraph - tumor characterization
            const para6Parts = [];
            
            if (categorizedTools.purity) {
                const purityTools = categorizedTools.purity.tools.map(t => formatToolVersion(t));
                para6Parts.push(`Tumor purity and ploidy were estimated using ${formatList(purityTools)}`);
            }
            
            if (categorizedTools.cnv) {
                const cnvTools = categorizedTools.cnv.tools.map(t => formatToolVersion(t));
                para6Parts.push(`copy number alterations were identified using ${formatList(cnvTools)}`);
            }
            
            if (para6Parts.length > 0) {
                let para6 = para6Parts[0].charAt(0).toUpperCase() + para6Parts[0].slice(1);
                if (para6Parts.length > 1) {
                    if (para6Parts.length === 2) {
                        para6 += ' and ' + para6Parts[1];
                    } else {
                        para6 += ', ' + para6Parts.slice(1, -1).join(', ') + ', and ' + para6Parts[para6Parts.length - 1];
                    }
                }
                para6 += '.';
                paragraphs.push(para6);
            }
            
            // Seventh paragraph - immunogenomics
            const para7Parts = [];
            
            if (categorizedTools.mhc) {
                const mhcTools = categorizedTools.mhc.tools.map(t => formatToolVersion(t));
                para7Parts.push(`Patient HLA types were determined using ${formatList(mhcTools)}`);
            }
            
            if (categorizedTools.loh) {
                const lohTools = categorizedTools.loh.tools.map(t => formatToolVersion(t));
                para7Parts.push(`HLA loss of heterozygosity was assessed using ${formatList(lohTools)}`);
            }
            
            if (categorizedTools.neoantigen) {
                const neoTools = categorizedTools.neoantigen.tools.map(t => formatToolVersion(t));
                let neoText = `neoantigen candidates were predicted using ${formatList(neoTools)}`;
                if (workflowParams.peptide_lengths) {
                    neoText += ` for peptides of ${workflowParams.peptide_lengths} amino acids in length`;
                }
                if (workflowParams.binding_affinity_threshold) {
                    neoText += `, and peptide-MHC binding predictions were filtered at an IC50 threshold of ${workflowParams.binding_affinity_threshold} nM`;
                }
                para7Parts.push(neoText);
            }
            
            if (para7Parts.length > 0) {
                let para7 = para7Parts[0].charAt(0).toUpperCase() + para7Parts[0].slice(1);
                if (para7Parts.length > 1) {
                    if (para7Parts.length === 2) {
                        para7 += ', and ' + para7Parts[1];
                    } else {
                        para7 += ', ' + para7Parts.slice(1, -1).join(', ') + ', and ' + para7Parts[para7Parts.length - 1];
                    }
                }
                para7 += '.';
                paragraphs.push(para7);
            }
            
            // Join all paragraphs
            methods.push(paragraphs.join('\n\n'));
            
            // Update textarea
            document.getElementById('methodsOutput').value = methods.join('\n');
        }
        
        // Helper function to clean version strings
        function cleanVersionString(version) {
            if (!version || version === 'latest') return version;
            
            // Extract base version number (e.g., "0.7.0-lens-compat-mhcflurry" -> "0.7.0")
            const match = version.match(/^v?(\d+\.\d+\.?\d*)/);
            if (match) {
                return match[1];
            }
            
            return version;
        }
        
        // Helper function to format tool with version
        function formatToolVersion(toolObj) {
            const label = getToolLabel(toolObj.tool);
            if (toolObj.version && toolObj.version !== 'latest') {
                return `${label} v${toolObj.version}`;
            }
            return label;
        }
        
        // Helper function to format lists with proper grammar
        function formatList(items) {
            if (items.length === 0) return '';
            if (items.length === 1) return items[0];
            if (items.length === 2) return `${items[0]} and ${items[1]}`;
            return items.slice(0, -1).join(', ') + ', and ' + items[items.length - 1];
        }

        function generateConfigOutput() {
            const config = [];
            
            config.push('// RAFT Workflow Configuration');
            config.push(`// Generated: ${new Date().toISOString()}`);
            config.push(`// Workflow: ${state.workflow}`);
            config.push(`// Species: ${state.species}`);
            config.push(`// Starting Data: ${state.startingData}`);
            config.push(`// Version: ${state.version}`);
            config.push('');

            const toolGroups = {};
            const workflowParamValues = {}; // Collect workflow parameter values
            
            // Collect workflow parameters
            document.querySelectorAll('.workflow-param').forEach(input => {
                const parameter = input.dataset.parameter;
                const value = input.value;
                workflowParamValues[parameter] = value;
            });
            
            document.querySelectorAll('.tool-checkbox:checked').forEach(checkbox => {
                const parameter = checkbox.name;
                const toolValue = checkbox.value;
                const optionDiv = checkbox.closest('.flex.items-start');
                
                // Check if this is a custom container or version select
                const customContainerInput = optionDiv.querySelector('input[data-is-custom-container="true"]');
                const versionSelect = optionDiv.querySelector('select');
                const paramsInput = optionDiv.querySelector('input[type="text"]:not([data-is-custom-container])');
                
                let version = 'latest';
                let customContainer = null;
                
                if (customContainerInput) {
                    customContainer = customContainerInput.value.trim();
                } else if (versionSelect) {
                    version = versionSelect.value;
                }
                
                if (!toolGroups[parameter]) {
                    toolGroups[parameter] = {
                        tools: [],
                        versions: [],
                        customContainers: [],
                        params: [],
                        parameterField: null
                    };
                }
                
                toolGroups[parameter].tools.push(toolValue);
                toolGroups[parameter].versions.push(version);
                toolGroups[parameter].customContainers.push(customContainer);
                toolGroups[parameter].params.push({
                    tool: toolValue,
                    params: paramsInput ? paramsInput.value.trim() : ''
                });
                
                const toolConfig = findToolConfig(parameter);
                if (toolConfig) {
                    toolGroups[parameter].parameterField = toolConfig.parameterField;
                }
            });

            config.push('// Tool Selections');
            Object.keys(toolGroups).forEach(parameter => {
                const group = toolGroups[parameter];
                config.push(`${parameter} = "${group.tools.join(',')}"`);
            });
            
            config.push('');
            config.push('// Workflow Parameters');
            Object.keys(workflowParamValues).sort().forEach(parameter => {
                const value = workflowParamValues[parameter];
                config.push(`${parameter} = "${value}"`);
            });

            config.push('');
            config.push('// Tool Parameters');
            Object.keys(toolGroups).forEach(parameter => {
                const group = toolGroups[parameter];
                if (!group.parameterField) return;
                
                const paramPairs = group.params
                    .filter(p => p.params)
                    .map(p => `${p.tool}:${p.params}`)
                    .join(',');
                
                const paramString = paramPairs ? `[${paramPairs}]` : '[]';
                config.push(`${group.parameterField} = "${paramString}"`);
            });

            config.push('');
            config.push('// === CONTAINERS ===');
            config.push('// Format: tool = container_image (used by raft update-parameters)');
            config.push('// Note: Tool names are mapped to nextflow.config labels automatically');
            Object.keys(toolGroups).forEach(parameter => {
                const group = toolGroups[parameter];
                group.tools.forEach((tool, index) => {
                    const customContainer = group.customContainers[index];
                    let containerImage;

                    // Get the container lookup name (may differ from tool name)
                    let containerLookupName = tool;

                    // Special handling for sequenza split tools
                    if (tool === 'sequenza_r') {
                        containerLookupName = 'r-sequenza';
                    } else if (tool === 'sequenza_utils') {
                        containerLookupName = 'sequenza-utils';
                    }

                    if (customContainer) {
                        // Custom container path
                        containerImage = customContainer;
                    } else {
                        // Check if this is a DockerHub or BioContainers image
                        const cachedData = biocontainersCache[containerLookupName] || biocontainersCache[tool];
                        const version = group.versions[index];

                        if (cachedData && cachedData.account && cachedData.repo) {
                            // DockerHub image
                            containerImage = `${cachedData.account}/${cachedData.repo}:${version}`;
                        } else {
                            // BioContainers image
                            containerImage = `quay.io/biocontainers/${containerLookupName}:${version}`;
                        }
                    }
                    config.push(`// ${tool} = ${containerImage}`);
                });
            });

            document.getElementById('configOutput').value = config.join('\n');
            generateMethodsDescription(); // Generate methods description alongside config
        }
        
        function findToolConfig(parameter) {
            // This would need to search through the parsed config structure
            // For now, we'll construct the parameter field name
            return {
                parameterField: parameter + '_parameters'
            };
        }

        function copyConfigToClipboard() {
            const textarea = document.getElementById('configOutput');
            textarea.select();
            document.execCommand('copy');
            
            const button = document.getElementById('copyConfig');
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.classList.add('bg-green-700');
            
            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove('bg-green-700');
            }, 2000);
        }

        function downloadConfigFile() {
            const content = document.getElementById('configOutput').value;
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${state.workflow}.${state.species}.${state.startingData}.config`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function copyMethodsToClipboard() {
            const textarea = document.getElementById('methodsOutput');
            textarea.select();
            document.execCommand('copy');
            
            const button = document.getElementById('copyMethods');
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.classList.add('bg-green-700');
            
            setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove('bg-green-700');
            }, 2000);
        }
        
        function downloadMethodsFile() {
            const content = document.getElementById('methodsOutput').value;
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${state.workflow}.${state.species}.${state.startingData}.methods.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
        }

        console.log('RAFT Configuration Generator initialized with real LENS data');
    </script>
</body>
</html>
